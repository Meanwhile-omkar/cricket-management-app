@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
"use client";

import { useState } from "react";
import MatchList from "@/components/MatchList";
import MatchViewer from "@/components/MatchViewer";

export default function ViewerPage() {
  const [selectedMatchId, setSelectedMatchId] = useState<string | null>(null);

  if (selectedMatchId) {
    return <MatchViewer matchId={selectedMatchId} onBack={() => setSelectedMatchId(null)} />;
  }

  return <MatchList onSelectMatch={setSelectedMatchId} />;
}
"use client";

import { useEffect, useState } from "react";
import { ref, onValue } from "firebase/database";
import { db } from "@/lib/firebase";
import { MatchData } from "@/types";

interface MatchWithId extends MatchData {
  matchId: string;
}

interface Props {
  onSelectMatch: (matchId: string) => void;
}

export default function MatchList({ onSelectMatch }: Props) {
  const [matches, setMatches] = useState<MatchWithId[]>([]);
  const [filter, setFilter] = useState<"all" | "live" | "completed">("live");

  useEffect(() => {
    const matchesRef = ref(db, "matches");
    return onValue(matchesRef, (snapshot) => {
      const data = snapshot.val();
      if (data) {
        const matchList: MatchWithId[] = Object.entries(data).map(([id, match]: any) => ({
          ...match,
          matchId: id,
        }));
        setMatches(matchList.sort((a, b) => b.lastUpdatedAt - a.lastUpdatedAt));
      } else {
        setMatches([]);
      }
    });
  }, []);

  const filteredMatches = matches.filter((match) => {
    if (filter === "live") return match.meta.status === "LIVE" || match.meta.status === "INNINGS_BREAK";
    if (filter === "completed") return match.meta.status === "COMPLETED";
    return true;
  });

  const getStatusBadge = (status: string) => {
    const badges = {
      NOT_STARTED: "bg-gray-100 text-gray-700",
      LIVE: "bg-green-100 text-green-700 animate-pulse",
      INNINGS_BREAK: "bg-yellow-100 text-yellow-700",
      COMPLETED: "bg-blue-100 text-blue-700",
    };
    return badges[status as keyof typeof badges] || "bg-gray-100 text-gray-700";
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100">
      {/* Header */}
      <div className="bg-white border-b shadow-sm">
        <div className="max-w-7xl mx-auto px-4 py-6">
          <div className="text-center">
            <div className="text-5xl mb-3">ðŸ</div>
            <h1 className="text-3xl font-bold text-gray-900 mb-2">Live Cricket Matches</h1>
            <p className="text-gray-600">Select a match to watch live scores</p>
          </div>
        </div>
      </div>

      {/* Filter Tabs */}
      <div className="bg-white border-b">
        <div className="max-w-7xl mx-auto px-4">
          <div className="flex justify-center space-x-4 py-4">
            <button
              onClick={() => setFilter("all")}
              className={`px-6 py-2 rounded-lg font-medium transition ${
                filter === "all" ? "bg-blue-600 text-white" : "bg-white text-gray-700 border hover:bg-gray-50"
              }`}
            >
              All Matches
            </button>
            <button
              onClick={() => setFilter("live")}
              className={`px-6 py-2 rounded-lg font-medium transition ${
                filter === "live" ? "bg-green-600 text-white" : "bg-white text-gray-700 border hover:bg-gray-50"
              }`}
            >
              ðŸ”´ Live
            </button>
            <button
              onClick={() => setFilter("completed")}
              className={`px-6 py-2 rounded-lg font-medium transition ${
                filter === "completed" ? "bg-blue-600 text-white" : "bg-white text-gray-700 border hover:bg-gray-50"
              }`}
            >
              Completed
            </button>
          </div>
        </div>
      </div>

      {/* Match Cards */}
      <div className="max-w-7xl mx-auto px-4 py-8">
        {filteredMatches.length === 0 ? (
          <div className="bg-white rounded-xl p-16 text-center shadow-lg">
            <div className="text-6xl mb-4">ðŸ</div>
            <h3 className="text-xl font-bold text-gray-900 mb-2">No matches found</h3>
            <p className="text-gray-600">
              {filter === "live" ? "No live matches at the moment" : "No completed matches yet"}
            </p>
          </div>
        ) : (
          <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            {filteredMatches.map((match) => (
              <div
                key={match.matchId}
                onClick={() => onSelectMatch(match.matchId)}
                className="bg-white rounded-xl p-6 shadow-lg hover:shadow-xl transition cursor-pointer border-2 border-transparent hover:border-blue-500"
              >
                <div className="flex justify-between items-start mb-4">
                  <div className="flex-1">
                    <h3 className="font-bold text-lg text-gray-900 mb-1">
                      {match.meta.teamA} vs {match.meta.teamB}
                    </h3>
                    <p className="text-sm text-gray-500">{match.meta.oversPerInnings} overs per innings</p>
                  </div>
                  <span className={`px-3 py-1 rounded-full text-xs font-bold ${getStatusBadge(match.meta.status)}`}>
                    {match.meta.status.replace("_", " ")}
                  </span>
                </div>

                {match.meta.status !== "NOT_STARTED" && (
                  <div className="mb-4">
                    <div className="text-4xl font-black text-gray-900 mb-1">
                      {match.state.totalRuns}/{match.state.totalWickets}
                    </div>
                    <div className="text-sm text-gray-600">
                      {match.state.oversBowled}.{match.state.ballsInCurrentOver} / {match.meta.oversPerInnings} overs
                      {match.meta.innings === 2 && <span className="ml-2">â€¢ Innings {match.meta.innings}</span>}
                    </div>

                    {match.meta.innings === 2 && match.meta.targetScore && (
                      <div className="mt-2 p-2 bg-green-50 rounded-lg border border-green-200">
                        <p className="text-sm font-semibold text-green-800">
                          Target: {match.meta.targetScore} â€¢ Need {match.meta.targetScore - match.state.totalRuns} runs
                        </p>
                      </div>
                    )}
                  </div>
                )}

                {match.meta.status === "COMPLETED" && match.meta.matchResult && (
                  <div className="mb-4 p-4 bg-gradient-to-r from-yellow-50 to-amber-50 rounded-lg border-2 border-yellow-300">
                    <p className="text-sm font-bold text-yellow-900 text-center">{match.meta.matchResult}</p>
                  </div>
                )}

                <div className="pt-4 border-t">
                  <button className="w-full text-blue-600 hover:text-blue-700 font-semibold text-sm">
                    {match.meta.status === "LIVE" || match.meta.status === "INNINGS_BREAK" ? "Watch Live â†’" : "View Scorecard â†’"}
                  </button>
                </div>
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
"use client";

import { useEffect, useState } from "react";
import { ref, onValue } from "firebase/database";
import { db } from "@/lib/firebase";
import { MatchData, Ball } from "@/types";
import {
  calculateBatsmanStats,
  calculateBowlerStats,
  calculateFallOfWickets,
  calculateRequiredRunRate,
  calculateRunRate,
} from "@/lib/statsCalculator";

interface Props {
  matchId: string;
  onBack: () => void;
}

export default function MatchViewer({ matchId, onBack }: Props) {
  const [match, setMatch] = useState<MatchData | null>(null);
  const [showBattingCard, setShowBattingCard] = useState(false);
  const [showBowlingCard, setShowBowlingCard] = useState(false);
  const [showFallOfWickets, setShowFallOfWickets] = useState(false);

  useEffect(() => {
    const matchRef = ref(db, `matches/${matchId}`);
    return onValue(matchRef, (snapshot) => {
      const data = snapshot.val();
      if (data) setMatch({ ...data, balls: data.balls || [] });
    });
  }, [matchId]);

  if (!match) return (
    <div className="h-screen flex items-center justify-center text-slate-500">
      <div>
        <div className="text-6xl mb-4 text-center">ðŸ</div>
        <p>Loading match...</p>
      </div>
    </div>
  );

  const { state, meta, balls, squads } = match;
  const recentBalls = [...balls].reverse().slice(0, 6);

  const getBallBadge = (b: Ball) => {
    let text = b.runsScored.toString();
    let color = "bg-gray-100 text-gray-800 border-gray-200";

    if (b.isWicket) { text = "W"; color = "bg-red-500 text-white border-red-600"; }
    else if (b.runsScored === 4) { color = "bg-green-500 text-white border-green-600"; }
    else if (b.runsScored === 6) { color = "bg-indigo-600 text-white border-indigo-700"; }
    else if (b.isWide) { text = "WD"; color = "bg-orange-100 text-orange-800 border-orange-200"; }
    else if (b.isNoBall) { text = "NB"; color = "bg-yellow-100 text-yellow-800 border-yellow-200"; }
    else if (b.isBye) { text = `${b.runsScored}b`; color = "bg-blue-100 text-blue-800 border-blue-200"; }
    else if (b.isLegBye) { text = `${b.runsScored}lb`; color = "bg-purple-100 text-purple-800 border-purple-200"; }

    return <div className={`w-10 h-10 rounded-full flex items-center justify-center font-bold border-2 ${color} text-xs`}>{text}</div>;
  };

  // Calculate stats for current players
  const strikerStats = state.currentStriker ? calculateBatsmanStats(balls, state.currentStriker) : null;
  const nonStrikerStats = state.currentNonStriker ? calculateBatsmanStats(balls, state.currentNonStriker) : null;
  const bowlerStats = state.currentBowler ? calculateBowlerStats(balls, state.currentBowler) : null;

  // Calculate innings stats
  const isTeamABatting = meta.battingTeam === meta.teamA;
  const battingSquad = isTeamABatting ? squads.teamA : squads.teamB;
  const bowlingSquad = isTeamABatting ? squads.teamB : squads.teamA;

  const allBatsmanStats = Object.values(
    battingSquad.reduce((acc, player) => {
      const stats = calculateBatsmanStats(balls, player);
      if (stats.balls > 0 || stats.isOut) {
        acc[player] = stats;
      }
      return acc;
    }, {} as Record<string, any>)
  );

  const allBowlerStats = Object.values(
    bowlingSquad.reduce((acc, player) => {
      const stats = calculateBowlerStats(balls, player);
      if (stats.balls > 0 || stats.overs > 0) {
        acc[player] = stats;
      }
      return acc;
    }, {} as Record<string, any>)
  );

  const fallOfWickets = calculateFallOfWickets(balls);
  const currentRunRate = calculateRunRate(state.totalRuns, state.legalBalls);

  // Target tracking for innings 2
  const runsNeeded = meta.targetScore ? meta.targetScore - state.totalRuns : 0;
  const ballsRemaining = (meta.oversPerInnings * 6) - state.legalBalls;
  const requiredRunRate = meta.targetScore ? calculateRequiredRunRate(meta.targetScore, state.totalRuns, ballsRemaining) : 0;

  // Match completed display
  if (meta.status === "COMPLETED") {
    return (
      <main className="min-h-screen bg-slate-100">
        <div className="bg-white border-b p-4">
          <button onClick={onBack} className="text-blue-600 hover:text-blue-700 font-medium">
            â† Back to Matches
          </button>
        </div>

        <div className="max-w-2xl mx-auto p-6">
          <div className="bg-white shadow-xl rounded-xl p-6">
            <h2 className="text-3xl font-bold mb-6 text-center text-slate-900">Match Completed</h2>

            <div className="mb-8 p-6 bg-gradient-to-r from-yellow-50 to-yellow-100 rounded-lg border-2 border-yellow-400">
              <p className="text-center text-2xl font-bold text-yellow-900">
                {match.meta.matchResult}
              </p>
            </div>

            <div className="grid md:grid-cols-2 gap-6 mb-6">
              <div className="p-6 bg-blue-50 rounded-lg border border-blue-200">
                <h3 className="font-bold text-xl mb-3 text-blue-900">{match.innings1?.battingTeam}</h3>
                <p className="text-4xl font-bold text-blue-800 mb-2">
                  {match.innings1?.totalRuns}/{match.innings1?.totalWickets}
                </p>
                <p className="text-sm text-slate-600">
                  {match.innings1?.oversBowled}.{match.innings1?.ballsInCurrentOver} overs
                </p>
              </div>

              <div className="p-6 bg-green-50 rounded-lg border border-green-200">
                <h3 className="font-bold text-xl mb-3 text-green-900">{match.innings2?.battingTeam}</h3>
                <p className="text-4xl font-bold text-green-800 mb-2">
                  {match.innings2?.totalRuns}/{match.innings2?.totalWickets}
                </p>
                <p className="text-sm text-slate-600">
                  {match.innings2?.oversBowled}.{match.innings2?.ballsInCurrentOver} overs
                </p>
              </div>
            </div>

            {match.innings1 && match.innings1.fallOfWickets && match.innings1.fallOfWickets.length > 0 && (
              <div className="mb-6">
                <h3 className="font-bold text-lg mb-3">Fall of Wickets - {match.innings1.battingTeam}</h3>
                <div className="grid grid-cols-2 gap-2 text-sm">
                  {match.innings1.fallOfWickets.map((fow, i) => (
                    <div key={i} className="p-2 bg-slate-50 rounded">
                      {fow.wicketNumber}. {fow.playerOut} ({fow.score}/{fow.wicketNumber}, {fow.oversBowled}.{fow.ballsInOver} ov)
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      </main>
    );
  }

  // Innings break display
  if (meta.status === "INNINGS_BREAK") {
    return (
      <main className="min-h-screen bg-slate-100">
        <div className="bg-white border-b p-4">
          <button onClick={onBack} className="text-blue-600 hover:text-blue-700 font-medium">
            â† Back to Matches
          </button>
        </div>

        <div className="max-w-md mx-auto p-6">
          <div className="bg-white shadow-xl rounded-xl p-6">
            <h2 className="text-2xl font-bold mb-6 text-center text-blue-900">Innings Break</h2>

            <div className="mb-6 p-6 bg-blue-50 rounded-lg border border-blue-200">
              <h3 className="font-bold text-lg mb-3">{match.innings1?.battingTeam} Innings</h3>
              <p className="text-5xl font-bold text-blue-900 mb-2">
                {match.innings1?.totalRuns}/{match.innings1?.totalWickets}
              </p>
              <p className="text-sm text-slate-600">
                Overs: {match.innings1?.oversBowled}.{match.innings1?.ballsInCurrentOver}
              </p>
            </div>

            <div className="mb-6 p-4 bg-green-50 rounded-lg border-2 border-green-300">
              <p className="text-center text-lg">
                <span className="font-bold">{meta.bowlingTeam}</span> needs{" "}
                <span className="text-3xl font-bold text-green-700 block mt-2">
                  {(match.innings1?.totalRuns ?? 0) + 1}
                </span>{" "}
                <span className="text-sm text-slate-600">runs to win</span>
              </p>
            </div>
          </div>
        </div>
      </main>
    );
  }

  // Live match display (same as original, but with back button)
  return (
    <main className="min-h-screen bg-slate-100 flex justify-center font-sans">
      <div className="w-full max-w-md bg-white shadow-xl min-h-screen flex flex-col relative">

        {/* Back Button */}
        <div className="bg-white border-b p-3 sticky top-0 z-20">
          <button onClick={onBack} className="text-blue-600 hover:text-blue-700 font-medium text-sm">
            â† Back to Matches
          </button>
        </div>

        {/* Scorecard Header */}
        <div className="bg-slate-900 text-white p-6 pb-16 rounded-b-[2rem] relative overflow-hidden">
          <div className="flex justify-between text-xs font-bold tracking-widest text-slate-400 mb-4 uppercase">
            <span>{meta.battingTeam}</span>
            <span>Innings {meta.innings}/2</span>
            <span>vs {meta.bowlingTeam}</span>
          </div>

          <div className="text-center">
            <h1 className="text-7xl font-black">{state.totalRuns}<span className="text-4xl font-light text-slate-400">/{state.totalWickets}</span></h1>
            <div className="mt-2 text-xl font-medium text-slate-300">
              Overs: {state.oversBowled}.{state.ballsInCurrentOver} <span className="text-sm opacity-50">/ {meta.oversPerInnings}</span>
            </div>

            {meta.innings === 2 && meta.targetScore && (
              <div className="mt-3 p-3 bg-yellow-500/20 rounded-lg border border-yellow-400">
                <div className="text-yellow-300 text-sm font-bold">TARGET: {meta.targetScore}</div>
                <div className="text-2xl font-bold text-yellow-100 mt-1">Need {runsNeeded} runs</div>
                <div className="text-xs text-yellow-200 mt-1">
                  CRR: {currentRunRate.toFixed(2)} | RRR: {requiredRunRate.toFixed(2)}
                </div>
              </div>
            )}

            {meta.innings !== 2 && (
              <div className="text-sm mt-2 text-blue-400 font-bold tracking-wide uppercase">
                {state.isFreeHit ? "âš ï¸ FREE HIT NEXT BALL âš ï¸" : `Run Rate: ${currentRunRate.toFixed(2)}`}
              </div>
            )}
          </div>
        </div>

        {/* Current Players Card */}
        <div className="mx-4 -mt-10 bg-white p-4 rounded-xl shadow-lg border border-slate-100 relative z-10">
          <div className="flex justify-between items-center mb-3 pb-3 border-b border-dashed border-slate-200">
            <div className="text-sm font-bold text-slate-700">Batting</div>
            <button
              onClick={() => setShowBattingCard(!showBattingCard)}
              className="text-xs text-blue-600 underline"
            >
              {showBattingCard ? "Hide" : "Full Scorecard"}
            </button>
          </div>

          {strikerStats && (
            <div className="p-3 rounded bg-green-50 mb-2">
              <div className="flex justify-between items-center">
                <div>
                  <span className="font-bold text-slate-900">â˜… {strikerStats.name}</span>
                  {strikerStats.isOut && <span className="text-xs text-red-600 ml-2">{strikerStats.howOut}</span>}
                </div>
                <span className="text-lg font-bold">{strikerStats.runs}({strikerStats.balls})</span>
              </div>
              <div className="text-xs text-slate-600 mt-1">
                4s: {strikerStats.fours} | 6s: {strikerStats.sixes} | SR: {strikerStats.strikeRate.toFixed(0)}
              </div>
            </div>
          )}

          {nonStrikerStats && (
            <div className="p-3 rounded">
              <div className="flex justify-between items-center">
                <div>
                  <span className="font-semibold text-slate-800">{nonStrikerStats.name}</span>
                  {nonStrikerStats.isOut && <span className="text-xs text-red-600 ml-2">{nonStrikerStats.howOut}</span>}
                </div>
                <span className="text-lg font-bold">{nonStrikerStats.runs}({nonStrikerStats.balls})</span>
              </div>
              <div className="text-xs text-slate-600 mt-1">
                4s: {nonStrikerStats.fours} | 6s: {nonStrikerStats.sixes} | SR: {nonStrikerStats.strikeRate.toFixed(0)}
              </div>
            </div>
          )}
        </div>

        {/* Rest of the components (batting card, bowler card, etc.) - same as original */}
        {showBattingCard && allBatsmanStats.length > 0 && (
          <div className="mx-4 mt-3 bg-white p-4 rounded-xl shadow border border-slate-100">
            <h3 className="font-bold text-sm mb-3 text-slate-700">Full Batting Card</h3>
            <div className="space-y-2 text-sm">
              {allBatsmanStats.map((stats: any, i: number) => (
                <div key={i} className="flex justify-between items-center p-2 rounded bg-slate-50">
                  <div className="flex-1">
                    <div className="font-semibold">{stats.name}</div>
                    {stats.howOut && <div className="text-xs text-red-600">{stats.howOut}</div>}
                  </div>
                  <div className="text-right">
                    <div className="font-bold">{stats.runs}({stats.balls})</div>
                    <div className="text-xs text-slate-500">
                      {stats.fours}Ã—4 {stats.sixes}Ã—6
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        <div className="mx-4 mt-3 bg-white p-4 rounded-xl shadow border border-slate-100">
          <div className="flex justify-between items-center mb-2">
            <div className="text-xs text-slate-400 uppercase font-bold">Bowling</div>
            <button
              onClick={() => setShowBowlingCard(!showBowlingCard)}
              className="text-xs text-blue-600 underline"
            >
              {showBowlingCard ? "Hide" : "All Bowlers"}
            </button>
          </div>

          {bowlerStats && (
            <div className="flex justify-between items-center">
              <div>
                <div className="font-bold text-slate-800 text-lg">{bowlerStats.name}</div>
                <div className="text-sm text-slate-600">
                  {bowlerStats.overs}.{bowlerStats.balls} - {bowlerStats.runs}/{bowlerStats.wickets}
                </div>
              </div>
              <div className="text-right text-sm">
                <div className="font-bold text-slate-600">Econ: {bowlerStats.economy}</div>
                {bowlerStats.maidens > 0 && <div className="text-xs">M: {bowlerStats.maidens}</div>}
              </div>
            </div>
          )}
        </div>

        {showBowlingCard && allBowlerStats.length > 0 && (
          <div className="mx-4 mt-3 bg-white p-4 rounded-xl shadow border border-slate-100">
            <h3 className="font-bold text-sm mb-3 text-slate-700">Full Bowling Card</h3>
            <div className="space-y-2 text-sm">
              {allBowlerStats.map((stats: any, i: number) => (
                <div key={i} className="flex justify-between items-center p-2 rounded bg-slate-50">
                  <div className="font-semibold">{stats.name}</div>
                  <div className="text-right">
                    <div className="font-bold">
                      {stats.overs}.{stats.balls} - {stats.runs}/{stats.wickets}
                    </div>
                    <div className="text-xs text-slate-500">Econ: {stats.economy}</div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {fallOfWickets.length > 0 && (
          <div className="mx-4 mt-3 bg-white p-4 rounded-xl shadow border border-slate-100">
            <div className="flex justify-between items-center mb-2">
              <h3 className="font-bold text-sm text-slate-700">Fall of Wickets</h3>
              <button
                onClick={() => setShowFallOfWickets(!showFallOfWickets)}
                className="text-xs text-blue-600 underline"
              >
                {showFallOfWickets ? "Hide" : "Show All"}
              </button>
            </div>

            {!showFallOfWickets && fallOfWickets.length > 0 && (
              <div className="text-sm text-slate-600">
                {fallOfWickets[fallOfWickets.length - 1].playerOut} ({fallOfWickets[fallOfWickets.length - 1].score}/{fallOfWickets[fallOfWickets.length - 1].wicketNumber}, {fallOfWickets[fallOfWickets.length - 1].oversBowled}.{fallOfWickets[fallOfWickets.length - 1].ballsInOver} ov)
              </div>
            )}

            {showFallOfWickets && (
              <div className="space-y-2 text-sm">
                {fallOfWickets.map((fow, i) => (
                  <div key={i} className="p-2 rounded bg-red-50 text-slate-800">
                    <span className="font-bold">{fow.wicketNumber}.</span> {fow.playerOut}{" "}
                    <span className="text-slate-600">
                      ({fow.score}/{fow.wicketNumber}, {fow.oversBowled}.{fow.ballsInOver} ov)
                    </span>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        <div className="p-6">
          <h3 className="text-xs font-bold text-slate-400 uppercase tracking-widest mb-4">This Over</h3>
          <div className="flex gap-3 overflow-x-auto pb-4">
            {recentBalls.length === 0 ? <span className="text-sm text-slate-400 italic">No balls yet</span> : recentBalls.map((b, i) => (
              <div key={i} className="flex-shrink-0">{getBallBadge(b)}</div>
            ))}
          </div>
        </div>

        <div className="mt-auto p-4 bg-slate-50 text-center text-xs text-slate-400">
          Status: {meta.status}
        </div>
      </div>
    </main>
  );
}
import { initializeApp, getApps, getApp } from "firebase/app";
import { getDatabase } from "firebase/database";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  databaseURL: process.env.NEXT_PUBLIC_FIREBASE_DB_URL,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// Singleton pattern to prevent multiple initializations
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
export const db = getDatabase(app);
import { Ball, BatsmanStats, BowlerStats, FallOfWicket, Partnership, InningsData, MatchState } from "@/types";

/**
 * Calculate batsman statistics from ball history
 */
export function calculateBatsmanStats(balls: Ball[], playerName: string): BatsmanStats {
  let runs = 0;
  let ballsFaced = 0;
  let fours = 0;
  let sixes = 0;
  let isOut = false;
  let howOut = "";

  balls.forEach((ball) => {
    // Check if this player was the striker
    if (ball.striker === playerName) {
      // Count balls faced (only legal balls)
      if (!ball.isWide && !ball.isNoBall) {
        ballsFaced++;
      }

      // Count runs (only runs off bat, not extras)
      const runsOffBat = ball.runsByBatsman ?? (ball.isBye || ball.isLegBye ? 0 : ball.runsScored);
      runs += runsOffBat;

      // Count boundaries
      if (runsOffBat === 4) fours++;
      if (runsOffBat === 6) sixes++;

      // Check if out
      if (ball.isWicket && ball.playerOut === playerName) {
        isOut = true;
        if (ball.wicketKind) {
          if (ball.wicketKind === "bowled") {
            howOut = `b ${ball.bowler}`;
          } else if (ball.wicketKind === "caught") {
            howOut = ball.fielder ? `c ${ball.fielder} b ${ball.bowler}` : `c & b ${ball.bowler}`;
          } else if (ball.wicketKind === "lbw") {
            howOut = `lbw b ${ball.bowler}`;
          } else if (ball.wicketKind === "stumped") {
            howOut = ball.fielder ? `st ${ball.fielder} b ${ball.bowler}` : `st b ${ball.bowler}`;
          } else if (ball.wicketKind === "run_out") {
            howOut = ball.fielder ? `run out (${ball.fielder})` : "run out";
          } else if (ball.wicketKind === "hit_wicket") {
            howOut = `hit wicket b ${ball.bowler}`;
          } else {
            howOut = "out";
          }
        }
      }
    }

    // Also check if non-striker and got run out
    if (ball.nonStriker === playerName && ball.isWicket && ball.playerOut === playerName) {
      isOut = true;
      howOut = ball.fielder ? `run out (${ball.fielder})` : "run out";
    }
  });

  const strikeRate = ballsFaced > 0 ? (runs / ballsFaced) * 100 : 0;

  const stats: any = {
    name: playerName,
    runs,
    balls: ballsFaced,
    fours,
    sixes,
    strikeRate: parseFloat(strikeRate.toFixed(2)),
    isOut,
  };

  // Only add howOut if player is actually out (Firebase doesn't accept undefined)
  if (isOut && howOut) {
    stats.howOut = howOut;
  }

  return stats;
}

/**
 * Calculate bowler statistics from ball history
 */
export function calculateBowlerStats(balls: Ball[], playerName: string): BowlerStats {
  let ballsBowled = 0;
  let runs = 0;
  let wickets = 0;
  let maidens = 0;
  let wides = 0;
  let noBalls = 0;

  // Group balls by over to calculate maidens
  const overBalls: Record<number, Ball[]> = {};

  balls.forEach((ball) => {
    if (ball.bowler === playerName) {
      // Count legal balls
      if (!ball.isWide && !ball.isNoBall) {
        ballsBowled++;
      }

      // Count runs (all runs conceded)
      runs += ball.runsScored;

      // Count wickets (excluding run outs)
      if (ball.isWicket && ball.wicketKind !== "run_out") {
        wickets++;
      }

      // Count extras
      if (ball.isWide) wides++;
      if (ball.isNoBall) noBalls++;

      // Group by over for maiden calculation
      if (!overBalls[ball.overNumber]) {
        overBalls[ball.overNumber] = [];
      }
      overBalls[ball.overNumber].push(ball);
    }
  });

  // Calculate maidens (overs with 0 runs)
  Object.values(overBalls).forEach((overBallsArray) => {
    const legalBallsInOver = overBallsArray.filter((b) => !b.isWide && !b.isNoBall).length;
    const runsInOver = overBallsArray.reduce((sum, b) => sum + b.runsScored, 0);

    // Maiden: 6 legal balls with 0 runs
    if (legalBallsInOver === 6 && runsInOver === 0) {
      maidens++;
    }
  });

  const overs = Math.floor(ballsBowled / 6);
  const remainingBalls = ballsBowled % 6;
  const economy = ballsBowled > 0 ? (runs / ballsBowled) * 6 : 0;

  return {
    name: playerName,
    overs,
    balls: remainingBalls,
    runs,
    wickets,
    economy: parseFloat(economy.toFixed(2)),
    maidens,
    wides,
    noBalls,
  };
}

/**
 * Calculate fall of wickets from ball history
 */
export function calculateFallOfWickets(balls: Ball[]): FallOfWicket[] {
  const fallOfWickets: FallOfWicket[] = [];
  let wicketCount = 0;
  let totalRuns = 0;

  balls.forEach((ball) => {
    totalRuns += ball.runsScored;

    if (ball.isWicket && ball.playerOut) {
      wicketCount++;
      const fow: any = {
        playerOut: ball.playerOut,
        score: totalRuns,
        wicketNumber: wicketCount,
        oversBowled: ball.overNumber,
        ballsInOver: ball.ballInOver,
        wicketKind: ball.wicketKind || "out",
        bowler: ball.bowler,
      };

      // Only add fielder if it exists (Firebase doesn't accept undefined)
      if (ball.fielder) {
        fow.fielder = ball.fielder;
      }

      fallOfWickets.push(fow);
    }
  });

  return fallOfWickets;
}

/**
 * Calculate partnerships from ball history
 */
export function calculatePartnerships(balls: Ball[]): Partnership[] {
  const partnerships: Partnership[] = [];
  let currentBatsman1: string | null = null;
  let currentBatsman2: string | null = null;
  let currentPartnershipRuns = 0;
  let currentPartnershipBalls = 0;
  let currentStartWicket = 0;

  balls.forEach((ball) => {
    // Initialize partnership if first ball
    if (!currentBatsman1 && !currentBatsman2) {
      currentBatsman1 = ball.striker;
      currentBatsman2 = ball.nonStriker;
    }

    // Check if batsmen changed (wicket fell or new partnership)
    const currentPair = [ball.striker, ball.nonStriker].sort();
    const previousPair = [currentBatsman1, currentBatsman2].sort();

    if (currentPair[0] !== previousPair[0] || currentPair[1] !== previousPair[1]) {
      // Save previous partnership
      if (currentBatsman1 && currentBatsman2) {
        partnerships.push({
          batsman1: currentBatsman1,
          batsman2: currentBatsman2,
          runs: currentPartnershipRuns,
          balls: currentPartnershipBalls,
          startWicket: currentStartWicket,
          endWicket: currentStartWicket + 1,
          isActive: false,
        });
      }

      // Start new partnership
      currentBatsman1 = ball.striker;
      currentBatsman2 = ball.nonStriker;
      currentPartnershipRuns = 0;
      currentPartnershipBalls = 0;
      currentStartWicket++;
    }

    // Count runs and balls for current partnership
    currentPartnershipRuns += ball.runsScored;
    if (!ball.isWide && !ball.isNoBall) {
      currentPartnershipBalls++;
    }
  });

  // Add final active partnership
  if (currentBatsman1 && currentBatsman2) {
    partnerships.push({
      batsman1: currentBatsman1,
      batsman2: currentBatsman2,
      runs: currentPartnershipRuns,
      balls: currentPartnershipBalls,
      startWicket: currentStartWicket,
      isActive: true,
    });
  }

  return partnerships;
}

/**
 * Calculate extras breakdown from ball history
 */
export function calculateExtras(balls: Ball[]): {
  wides: number;
  noBalls: number;
  byes: number;
  legByes: number;
  total: number;
} {
  let wides = 0;
  let noBalls = 0;
  let byes = 0;
  let legByes = 0;

  balls.forEach((ball) => {
    if (ball.isWide) wides += ball.runsScored;
    if (ball.isNoBall) noBalls += 1; // No-ball is always 1 + any runs
    if (ball.isBye) byes += ball.runsScored;
    if (ball.isLegBye) legByes += ball.runsScored;
  });

  return {
    wides,
    noBalls,
    byes,
    legByes,
    total: wides + noBalls + byes + legByes,
  };
}

/**
 * Calculate run rate
 */
export function calculateRunRate(runs: number, balls: number): number {
  if (balls === 0) return 0;
  const overs = balls / 6;
  return parseFloat((runs / overs).toFixed(2));
}

/**
 * Calculate required run rate for chase
 */
export function calculateRequiredRunRate(
  target: number,
  runsScored: number,
  ballsRemaining: number
): number {
  if (ballsRemaining === 0) return 0;
  const runsNeeded = target - runsScored;
  if (runsNeeded <= 0) return 0;
  const oversRemaining = ballsRemaining / 6;
  return parseFloat((runsNeeded / oversRemaining).toFixed(2));
}

/**
 * Calculate all batsmen statistics for an innings
 */
export function calculateAllBatsmanStats(balls: Ball[], squad: string[]): Record<string, BatsmanStats> {
  const stats: Record<string, BatsmanStats> = {};

  squad.forEach((playerName) => {
    const playerStats = calculateBatsmanStats(balls, playerName);
    // Only include if player has faced balls or is out
    if (playerStats.balls > 0 || playerStats.isOut) {
      stats[playerName] = playerStats;
    }
  });

  return stats;
}

/**
 * Calculate all bowler statistics for an innings
 */
export function calculateAllBowlerStats(balls: Ball[], squad: string[]): Record<string, BowlerStats> {
  const stats: Record<string, BowlerStats> = {};

  squad.forEach((playerName) => {
    const playerStats = calculateBowlerStats(balls, playerName);
    // Only include if player has bowled balls
    if (playerStats.balls > 0 || playerStats.overs > 0) {
      stats[playerName] = playerStats;
    }
  });

  return stats;
}

/**
 * Get current partnership from state
 */
export function getCurrentPartnership(state: MatchState): { runs: number; balls: number } {
  return {
    runs: state.currentPartnershipRuns ?? 0,
    balls: state.currentPartnershipBalls ?? 0,
  };
}
export type TeamName = "teamA" | "teamB";

export interface Player {
  id: string; // use name as ID for simplicity
  name: string;
}

export interface Wicket {
  isOut: boolean;
  kind?: "bowled" | "caught" | "run_out" | "lbw" | "stumped" | null;
  playerOut?: string; // name
}

// Player Statistics
export interface BatsmanStats {
  name: string;
  runs: number;
  balls: number;
  fours: number;
  sixes: number;
  strikeRate: number;
  isOut: boolean;
  howOut?: string;
}

export interface BowlerStats {
  name: string;
  overs: number;
  balls: number;
  runs: number;
  wickets: number;
  economy: number;
  maidens: number;
  wides: number;
  noBalls: number;
}

// Fall of Wickets
export interface FallOfWicket {
  playerOut: string;
  score: number;
  wicketNumber: number;
  oversBowled: number;
  ballsInOver: number;
  wicketKind: string;
  bowler: string;
  fielder?: string;
}

// Partnership
export interface Partnership {
  batsman1: string;
  batsman2: string;
  runs: number;
  balls: number;
  startWicket: number;
  endWicket?: number;
  isActive: boolean;
}

// Innings Data
export interface InningsData {
  battingTeam: string;
  bowlingTeam: string;
  totalRuns: number;
  totalWickets: number;
  oversBowled: number;
  ballsInCurrentOver: number;
  legalBalls: number;
  fallOfWickets: FallOfWicket[];
  partnerships: Partnership[];
  batsmanStats: Record<string, BatsmanStats>;
  bowlerStats: Record<string, BowlerStats>;
  extras: {
    wides: number;
    noBalls: number;
    byes: number;
    legByes: number;
    total: number;
  };
}

export interface Ball {
  ballNumber: number; // Global index
  overNumber: number;
  ballInOver: number; // 1-6 (or more if extras)

  // Scoring
  runsScored: number; // Total runs from this ball
  runsByBatsman?: number; // NEW: Runs off bat (for stats)
  extraRuns?: number; // NEW: Extra runs

  // Extras
  isWide: boolean;
  isNoBall: boolean;
  isBye?: boolean; // NEW
  isLegBye?: boolean; // NEW

  // Wickets
  isWicket: boolean;
  wicketKind?: string;
  playerOut?: string;
  fielder?: string; // NEW: For caught/run out/stumped

  // Context (Snapshot for Undo/History)
  striker: string;
  nonStriker: string;
  bowler: string;
  isFreeHit: boolean;

  // Partnership
  partnershipRuns?: number; // NEW
}

export interface MatchMeta {
  teamA: string; // Name
  teamB: string; // Name
  oversPerInnings: number;
  status: "NOT_STARTED" | "LIVE" | "INNINGS_BREAK" | "COMPLETED";
  innings: number;
  battingTeam: string; // Name
  bowlingTeam: string; // Name
  winningTeam?: string;

  // NEW: Second innings support
  targetScore?: number;
  matchResult?: string;
  matchResultType?: "runs" | "wickets" | "tie" | "no_result";
}

export interface MatchState {
  totalRuns: number;
  totalWickets: number;
  legalBalls: number; // Total legal balls bowled
  oversBowled: number; // e.g., 2
  ballsInCurrentOver: number; // e.g., 4

  // Current Actors
  currentStriker: string | null;
  currentNonStriker: string | null;
  currentBowler: string | null;

  isFreeHit: boolean; // Next ball is free hit?

  // NEW: Batting order tracking
  battingOrder?: string[];
  nextBatsmanIndex?: number;

  // NEW: Over history for bowling restrictions
  lastOverBowler?: string | null;

  // NEW: Current partnership
  currentPartnershipRuns?: number;
  currentPartnershipBalls?: number;
}

// Roster Storage
export interface Squads {
  teamA: string[];
  teamB: string[];
}

export interface MatchData {
  meta: MatchMeta;
  squads: Squads;
  state: MatchState;
  balls: Ball[];

  // NEW: Innings-wise data
  innings1?: InningsData;
  innings2?: InningsData;

  lastUpdatedAt: number;
}
