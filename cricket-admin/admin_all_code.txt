

===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\app\globals.css =====

@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\app\layout.tsx =====

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\app\page.tsx =====

"use client";

import { useEffect, useState } from "react";
import Login from "@/components/Login";
import AdminDashboard from "@/components/AdminDashboard";

export default function AdminPage() {
  const [adminId, setAdminId] = useState<string | null>(null);
  const [adminUsername, setAdminUsername] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Check for existing session
    const storedAdminId = localStorage.getItem('cricketAdminId');
    const storedUsername = localStorage.getItem('cricketAdminUsername');

    if (storedAdminId && storedUsername) {
      setAdminId(storedAdminId);
      setAdminUsername(storedUsername);
    }
    setLoading(false);
  }, []);

  const handleLogin = (id: string, username: string) => {
    setAdminId(id);
    setAdminUsername(username);
  };

  const handleLogout = () => {
    localStorage.removeItem('cricketAdminId');
    localStorage.removeItem('cricketAdminUsername');
    setAdminId(null);
    setAdminUsername(null);
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-6xl">ðŸ</div>
      </div>
    );
  }

  if (!adminId || !adminUsername) {
    return <Login onLogin={handleLogin} />;
  }

  return <AdminDashboard adminId={adminId} adminUsername={adminUsername} onLogout={handleLogout} />;
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\components\AdminDashboard.tsx =====

import { useState } from "react";
import AllMatches from "./AllMatches";
import CreateMatch from "./CreateMatch";
import LiveScoring from "./LiveScoring";

interface Props {
  adminId: string;
  adminUsername: string;
  onLogout: () => void;
}

type Tab = "matches" | "create" | "scoring";

export default function AdminDashboard({ adminId, adminUsername, onLogout }: Props) {
  const [activeTab, setActiveTab] = useState<Tab>("matches");
  const [selectedMatchId, setSelectedMatchId] = useState<string | null>(null);

  const handleMatchSelect = (matchId: string) => {
    setSelectedMatchId(matchId);
    setActiveTab("scoring");
  };

  const handleMatchCreated = (matchId: string) => {
    setSelectedMatchId(matchId);
    setActiveTab("scoring");
  };

  const handleBackToMatches = () => {
    setSelectedMatchId(null);
    setActiveTab("matches");
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* Header */}
      <div className="bg-white border-b sticky top-0 z-10 shadow-sm">
        <div className="max-w-7xl mx-auto px-4 py-4">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-2xl font-bold text-gray-900">ðŸ Cricket Scorer</h1>
              <p className="text-sm text-gray-600">Welcome, {adminUsername}</p>
            </div>
            <button
              onClick={onLogout}
              className="text-sm text-red-600 hover:text-red-700 font-medium"
            >
              Logout
            </button>
          </div>
        </div>
      </div>

      {/* Tabs - Only show when not in scoring mode */}
      {activeTab !== "scoring" && (
        <div className="bg-white border-b">
          <div className="max-w-7xl mx-auto px-4">
            <div className="flex space-x-8">
              <button
                onClick={() => setActiveTab("matches")}
                className={`py-4 px-2 border-b-2 font-medium text-sm transition ${
                  activeTab === "matches"
                    ? "border-blue-600 text-blue-600"
                    : "border-transparent text-gray-600 hover:text-gray-900"
                }`}
              >
                All Matches
              </button>
              <button
                onClick={() => setActiveTab("create")}
                className={`py-4 px-2 border-b-2 font-medium text-sm transition ${
                  activeTab === "create"
                    ? "border-blue-600 text-blue-600"
                    : "border-transparent text-gray-600 hover:text-gray-900"
                }`}
              >
                + Create Match
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Content */}
      <div className="max-w-7xl mx-auto p-4">
        {activeTab === "matches" && (
          <AllMatches
            adminId={adminId}
            adminUsername={adminUsername}
            onMatchSelect={handleMatchSelect}
          />
        )}

        {activeTab === "create" && (
          <CreateMatch
            adminId={adminId}
            adminUsername={adminUsername}
            onMatchCreated={handleMatchCreated}
          />
        )}

        {activeTab === "scoring" && selectedMatchId && (
          <LiveScoring
            matchId={selectedMatchId}
            adminId={adminId}
            adminUsername={adminUsername}
            onBack={handleBackToMatches}
          />
        )}
      </div>
    </div>
  );
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\components\AllMatches.tsx =====

import { useEffect, useState } from "react";
import { ref, onValue, update } from "firebase/database";
import { db } from "@/lib/firebase";
import { MatchData } from "@/types";

interface Props {
  adminId: string;
  adminUsername: string;
  onMatchSelect: (matchId: string) => void;
}

interface MatchWithId extends MatchData {
  matchId: string;
  createdBy?: string;
  lock?: {
    adminId: string | null;
    adminUsername: string | null;
    lockedAt: number | null;
  };
}

export default function AllMatches({ adminId, adminUsername, onMatchSelect }: Props) {
  const [matches, setMatches] = useState<MatchWithId[]>([]);
  const [filter, setFilter] = useState<"all" | "live" | "completed">("all");

  useEffect(() => {
    const matchesRef = ref(db, "matches");
    return onValue(matchesRef, (snapshot) => {
      const data = snapshot.val();
      if (data) {
        const matchList: MatchWithId[] = Object.entries(data).map(([id, match]: any) => ({
          ...match,
          matchId: id,
        }));
        setMatches(matchList.sort((a, b) => b.lastUpdatedAt - a.lastUpdatedAt));
      } else {
        setMatches([]);
      }
    });
  }, []);

  const handleLock = async (matchId: string) => {
    const matchRef = ref(db, `matches/${matchId}/lock`);
    await update(matchRef as any, {
      adminId,
      adminUsername,
      lockedAt: Date.now(),
    });
    onMatchSelect(matchId);
  };

  const filteredMatches = matches.filter((match) => {
    if (filter === "live") return match.meta.status === "LIVE" || match.meta.status === "INNINGS_BREAK";
    if (filter === "completed") return match.meta.status === "COMPLETED";
    return true;
  });

  const getStatusBadge = (status: string) => {
    const badges = {
      NOT_STARTED: "bg-gray-100 text-gray-700",
      LIVE: "bg-green-100 text-green-700",
      INNINGS_BREAK: "bg-yellow-100 text-yellow-700",
      COMPLETED: "bg-blue-100 text-blue-700",
    };
    return badges[status as keyof typeof badges] || "bg-gray-100 text-gray-700";
  };

  return (
    <div>
      <div className="mb-6 flex justify-between items-center">
        <h2 className="text-2xl font-bold text-gray-900">All Matches</h2>
        <div className="flex gap-2">
          <button
            onClick={() => setFilter("all")}
            className={`px-4 py-2 rounded-lg text-sm font-medium ${
              filter === "all" ? "bg-blue-600 text-white" : "bg-white text-gray-700 border"
            }`}
          >
            All
          </button>
          <button
            onClick={() => setFilter("live")}
            className={`px-4 py-2 rounded-lg text-sm font-medium ${
              filter === "live" ? "bg-green-600 text-white" : "bg-white text-gray-700 border"
            }`}
          >
            Live
          </button>
          <button
            onClick={() => setFilter("completed")}
            className={`px-4 py-2 rounded-lg text-sm font-medium ${
              filter === "completed" ? "bg-blue-600 text-white" : "bg-white text-gray-700 border"
            }`}
          >
            Completed
          </button>
        </div>
      </div>

      {filteredMatches.length === 0 ? (
        <div className="bg-white rounded-lg p-12 text-center border">
          <div className="text-6xl mb-4">ðŸ</div>
          <p className="text-gray-600 mb-4">No matches found</p>
          <p className="text-sm text-gray-500">Create your first match to get started</p>
        </div>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {filteredMatches.map((match) => (
            <div
              key={match.matchId}
              className="bg-white rounded-lg p-6 border hover:shadow-lg transition cursor-pointer"
              onClick={() => match.lock?.adminId === adminId || !match.lock?.adminId ? handleLock(match.matchId) : null}
            >
              <div className="flex justify-between items-start mb-4">
                <div>
                  <h3 className="font-bold text-lg text-gray-900">
                    {match.meta.teamA} vs {match.meta.teamB}
                  </h3>
                  <p className="text-sm text-gray-500">
                    {match.meta.oversPerInnings} overs
                  </p>
                </div>
                <span className={`px-3 py-1 rounded-full text-xs font-medium ${getStatusBadge(match.meta.status)}`}>
                  {match.meta.status.replace("_", " ")}
                </span>
              </div>

              {match.meta.status !== "NOT_STARTED" && (
                <div className="mb-4">
                  <div className="text-3xl font-bold text-gray-900">
                    {match.state.totalRuns}/{match.state.totalWickets}
                  </div>
                  <div className="text-sm text-gray-600">
                    {match.state.oversBowled}.{match.state.ballsInCurrentOver} overs
                  </div>
                  {match.meta.innings === 2 && match.meta.targetScore && (
                    <div className="text-sm text-green-600 font-medium mt-1">
                      Target: {match.meta.targetScore} runs
                    </div>
                  )}
                </div>
              )}

              {match.meta.status === "COMPLETED" && match.meta.matchResult && (
                <div className="mb-4 p-3 bg-yellow-50 rounded-lg border border-yellow-200">
                  <p className="text-sm font-medium text-yellow-900">{match.meta.matchResult}</p>
                </div>
              )}

              <div className="flex justify-between items-center pt-4 border-t">
                <div className="text-xs text-gray-500">
                  {match.lock?.adminId ? (
                    <span className="flex items-center gap-1">
                      ðŸ”’ {match.lock.adminId === adminId ? "You" : match.lock.adminUsername}
                    </span>
                  ) : (
                    <span className="text-green-600">ðŸŸ¢ Available</span>
                  )}
                </div>
                <button
                  className={`text-sm font-medium ${
                    match.lock?.adminId === adminId || !match.lock?.adminId
                      ? "text-blue-600 hover:text-blue-700"
                      : "text-gray-400"
                  }`}
                  onClick={() => match.lock?.adminId === adminId || !match.lock?.adminId ? handleLock(match.matchId) : null}
                >
                  {match.lock?.adminId === adminId ? "Continue" : !match.lock?.adminId ? "Start Scoring" : "Locked"}
                </button>
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\components\CreateMatch.tsx =====

import { useState } from "react";
import { ref, set } from "firebase/database";
import { db } from "@/lib/firebase";
import { MatchData } from "@/types";

interface Props {
  adminId: string;
  adminUsername: string;
  onMatchCreated: (matchId: string) => void;
}

export default function CreateMatch({ adminId, adminUsername, onMatchCreated }: Props) {
  const [teamA, setTeamA] = useState("");
  const [teamB, setTeamB] = useState("");
  const [overs, setOvers] = useState(10);
  const [rosterA, setRosterA] = useState("");
  const [rosterB, setRosterB] = useState("");
  const [loading, setLoading] = useState(false);

  const handleCreate = async () => {
    if (!teamA || !teamB || !rosterA || !rosterB) {
      alert("Please fill in all fields");
      return;
    }

    const squadA = rosterA.split("\n").map(s => s.trim()).filter(Boolean);
    const squadB = rosterB.split("\n").map(s => s.trim()).filter(Boolean);

    if (squadA.length < 2 || squadB.length < 2) {
      alert("Each team needs at least 2 players.");
      return;
    }

    setLoading(true);
    try {
      // Generate unique matchId
      const matchId = `match_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

      const newMatch: MatchData & { matchId: string; createdBy: string; lock: any } = {
        matchId,
        createdBy: adminId,
        lock: {
          adminId,
          adminUsername,
          lockedAt: Date.now(),
        },
        meta: {
          teamA,
          teamB,
          battingTeam: teamA,
          bowlingTeam: teamB,
          oversPerInnings: Number(overs),
          status: "LIVE",
          innings: 1,
        },
        squads: {
          teamA: squadA,
          teamB: squadB,
        },
        state: {
          totalRuns: 0,
          totalWickets: 0,
          legalBalls: 0,
          oversBowled: 0,
          ballsInCurrentOver: 0,
          currentStriker: null,
          currentNonStriker: null,
          currentBowler: null,
          isFreeHit: false,
          battingOrder: [],
          nextBatsmanIndex: 0,
          lastOverBowler: null,
          currentPartnershipRuns: 0,
          currentPartnershipBalls: 0,
        },
        balls: [],
        lastUpdatedAt: Date.now(),
      };

      await set(ref(db, `matches/${matchId}`), newMatch);
      onMatchCreated(matchId);
    } catch (error) {
      console.error("Error creating match:", error);
      alert("Failed to create match. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto">
      <h2 className="text-2xl font-bold mb-6 text-gray-900">Create New Match</h2>

      <div className="bg-white p-6 rounded-xl shadow-md space-y-6">
        <div className="grid md:grid-cols-2 gap-6">
          <div>
            <label className="block text-sm font-bold mb-2 text-gray-700">Team A Name (Batting First)</label>
            <input
              className="w-full border border-gray-300 p-3 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              value={teamA}
              onChange={e => setTeamA(e.target.value)}
              placeholder="e.g. India"
            />
          </div>

          <div>
            <label className="block text-sm font-bold mb-2 text-gray-700">Team B Name (Bowling First)</label>
            <input
              className="w-full border border-gray-300 p-3 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              value={teamB}
              onChange={e => setTeamB(e.target.value)}
              placeholder="e.g. Australia"
            />
          </div>
        </div>

        <div>
          <label className="block text-sm font-bold mb-2 text-gray-700">Team A Squad</label>
          <textarea
            className="w-full border border-gray-300 p-3 rounded-lg h-32 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            placeholder="Enter player names, one per line"
            value={rosterA}
            onChange={e => setRosterA(e.target.value)}
          />
          <p className="text-xs text-gray-500 mt-1">Minimum 2 players required</p>
        </div>

        <div>
          <label className="block text-sm font-bold mb-2 text-gray-700">Team B Squad</label>
          <textarea
            className="w-full border border-gray-300 p-3 rounded-lg h-32 text-sm focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            placeholder="Enter player names, one per line"
            value={rosterB}
            onChange={e => setRosterB(e.target.value)}
          />
          <p className="text-xs text-gray-500 mt-1">Minimum 2 players required</p>
        </div>

        <div>
          <label className="block text-sm font-bold mb-2 text-gray-700">Overs Per Innings</label>
          <input
            type="number"
            className="w-full border border-gray-300 p-3 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
            value={overs}
            onChange={e => setOvers(Number(e.target.value))}
            min={1}
            max={50}
          />
        </div>

        <button
          onClick={handleCreate}
          disabled={loading}
          className="w-full bg-blue-600 text-white py-4 rounded-lg font-bold text-lg hover:bg-blue-700 transition disabled:bg-gray-400 disabled:cursor-not-allowed"
        >
          {loading ? "Creating Match..." : "Create & Start Match"}
        </button>
      </div>
    </div>
  );
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\components\LiveScoring.tsx =====

import { useEffect, useState } from "react";
import { ref, onValue, update } from "firebase/database";
import { db } from "@/lib/firebase";
import { MatchData } from "@/types";
import ScoringDashboard from "./ScoringDashboard";

interface Props {
  matchId: string;
  adminId: string;
  adminUsername: string;
  onBack: () => void;
}

export default function LiveScoring({ matchId, adminId, adminUsername, onBack }: Props) {
  const [match, setMatch] = useState<MatchData | null>(null);
  const [canScore, setCanScore] = useState(false);

  useEffect(() => {
    const matchRef = ref(db, `matches/${matchId}`);
    return onValue(matchRef, (snapshot) => {
      const data = snapshot.val();
      if (data) {
        setMatch({ ...data, balls: data.balls || [] });

        // Check if this admin has the lock
        const hasLock = data.lock?.adminId === adminId;
        setCanScore(hasLock);

        if (!hasLock) {
          alert("This match is being scored by another admin");
        }
      }
    });
  }, [matchId, adminId]);

  const handleReleaseLock = async () => {
    if (confirm("Release lock and go back to matches?")) {
      await update(ref(db, `matches/${matchId}/lock`) as any, {
        adminId: null,
        adminUsername: null,
        lockedAt: null,
      });
      onBack();
    }
  };

  if (!match) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="text-6xl mb-4">ðŸ</div>
          <p className="text-gray-600">Loading match...</p>
        </div>
      </div>
    );
  }

  if (!canScore) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center bg-white p-8 rounded-lg shadow-lg">
          <div className="text-6xl mb-4">ðŸ”’</div>
          <h2 className="text-2xl font-bold mb-2">Match Locked</h2>
          <p className="text-gray-600 mb-4">
            This match is being scored by another admin
          </p>
          <button
            onClick={onBack}
            className="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700"
          >
            Back to Matches
          </button>
        </div>
      </div>
    );
  }

  return (
    <div>
      {/* Header with back button */}
      <div className="bg-white border-b mb-4 -mx-4 -mt-4 px-4 py-3 flex justify-between items-center sticky top-0 z-20">
        <button
          onClick={handleReleaseLock}
          className="text-blue-600 hover:text-blue-700 font-medium flex items-center gap-2"
        >
          â† Back to Matches
        </button>
        <div className="text-sm text-gray-600">
          Scoring as: <span className="font-medium text-gray-900">{adminUsername}</span>
        </div>
      </div>

      {/* Use existing ScoringDashboard */}
      <ScoringDashboard match={match} matchId={matchId} />
    </div>
  );
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\components\Login.tsx =====

import { useState } from "react";
import { ref, set, get } from "firebase/database";
import { db } from "@/lib/firebase";

interface Props {
  onLogin: (adminId: string, username: string) => void;
}

export default function Login({ onLogin }: Props) {
  const [username, setUsername] = useState("");
  const [loading, setLoading] = useState(false);

  const handleLogin = async () => {
    if (!username.trim()) {
      alert("Please enter a username");
      return;
    }

    setLoading(true);
    try {
      // Simple hash for adminId (in production, use proper auth)
      const adminId = btoa(username.toLowerCase().trim()).replace(/=/g, '');

      const adminRef = ref(db, `admins/${adminId}`);
      const snapshot = await get(adminRef);

      if (!snapshot.exists()) {
        // Create new admin
        await set(adminRef, {
          username: username.trim(),
          createdAt: Date.now(),
        });
      }

      // Store in localStorage
      localStorage.setItem('cricketAdminId', adminId);
      localStorage.setItem('cricketAdminUsername', username.trim());

      onLogin(adminId, username.trim());
    } catch (error) {
      console.error("Login error:", error);
      alert("Login failed. Please try again.");
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-6">
      <div className="bg-white rounded-2xl shadow-xl p-8 w-full max-w-md">
        <div className="text-center mb-8">
          <div className="text-6xl mb-4">ðŸ</div>
          <h1 className="text-3xl font-bold text-gray-900 mb-2">Cricket Scorer</h1>
          <p className="text-gray-600">Enter your username to continue</p>
        </div>

        <div className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Username
            </label>
            <input
              type="text"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && handleLogin()}
              placeholder="Enter your name"
              className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
              disabled={loading}
            />
          </div>

          <button
            onClick={handleLogin}
            disabled={loading || !username.trim()}
            className="w-full bg-blue-600 text-white py-3 rounded-lg font-semibold hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition"
          >
            {loading ? "Logging in..." : "Continue"}
          </button>
        </div>

        <p className="text-xs text-gray-500 text-center mt-6">
          No password required â€¢ Simple username-based login
        </p>
      </div>
    </div>
  );
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\components\ScoringDashboard.tsx =====

import { useState, useEffect } from "react";
import { ref, set, update } from "firebase/database";
import { db } from "@/lib/firebase";
import { MatchData } from "@/types";
import { processBallDelivery } from "@/lib/ballProcessor";
import { validateBowlerSelection } from "@/lib/cricketRules";
import { calculateBatsmanStats, calculateBowlerStats } from "@/lib/statsCalculator";
import { saveInningsData, prepareInnings2State, calculateMatchResult } from "@/lib/inningsManager";

interface Props {
  match: MatchData;
  matchId?: string; // Optional for backward compatibility
}

export default function ScoringDashboard({ match, matchId }: Props) {
  const dbPath = matchId ? `matches/${matchId}` : "match"; // Support both old and new structure
  // --- LOCAL STATE (Buffers) ---
  const [localStriker, setLocalStriker] = useState(match.state?.currentStriker || "");
  const [localNonStriker, setLocalNonStriker] = useState(match.state?.currentNonStriker || "");
  const [localBowler, setLocalBowler] = useState(match.state?.currentBowler || "");
  const [bowlerError, setBowlerError] = useState("");

  // Sync Local State with DB
  useEffect(() => {
    if (match.state?.currentStriker) setLocalStriker(match.state.currentStriker);
    if (match.state?.currentNonStriker) setLocalNonStriker(match.state.currentNonStriker);
    if (match.state?.currentBowler) setLocalBowler(match.state.currentBowler);
  }, [match.state?.currentStriker, match.state?.currentNonStriker, match.state?.currentBowler]);

  // Scoring Inputs
  const [runs, setRuns] = useState(0);
  const [extrasType, setExtrasType] = useState<"NONE" | "WD" | "NB" | "BYE" | "LB">("NONE");

  // Wicket Inputs
  const [isWicket, setIsWicket] = useState(false);
  const [wicketWho, setWicketWho] = useState<"striker" | "nonStriker">("striker");
  const [wicketKind, setWicketKind] = useState<"bowled" | "caught" | "run_out" | "lbw" | "stumped" | "hit_wicket">("bowled");
  const [fielder, setFielder] = useState("");

  // Helpers
  const isTeamABatting = match.meta.battingTeam === match.meta.teamA;
  const battingSquad = isTeamABatting ? match.squads.teamA : match.squads.teamB;
  const bowlingSquad = isTeamABatting ? match.squads.teamB : match.squads.teamA;

  // Calculate current stats
  const strikerStats = localStriker ? calculateBatsmanStats(match.balls, localStriker) : null;
  const nonStrikerStats = localNonStriker ? calculateBatsmanStats(match.balls, localNonStriker) : null;
  const bowlerStats = localBowler ? calculateBowlerStats(match.balls, localBowler) : null;

  // --- ACTIONS ---

  const handleUpdatePlayer = (role: "striker" | "nonStriker" | "bowler", name: string) => {
    if (!match || !match.state) return;

    if (role === 'striker' && name === localNonStriker) {
      return alert("Player already at crease as non-striker");
    }
    if (role === 'nonStriker' && name === localStriker) {
      return alert("Player already at crease as striker");
    }

    // Validate bowler selection
    if (role === 'bowler') {
      const validation = validateBowlerSelection(
        match.state.currentBowler,
        match.state.lastOverBowler,
        name
      );

      if (!validation.valid) {
        setBowlerError(validation.error || "Invalid bowler selection");
        return;
      } else {
        setBowlerError("");
      }
    }

    // INSTANT UI UPDATE
    if (role === 'striker') setLocalStriker(name);
    if (role === 'nonStriker') setLocalNonStriker(name);
    if (role === 'bowler') setLocalBowler(name);

    // BACKGROUND DB UPDATE
    const stateKey = role === 'striker' ? 'currentStriker'
                   : role === 'nonStriker' ? 'currentNonStriker'
                   : 'currentBowler';

    update(ref(db, `${dbPath}/state`), {
      [stateKey]: name
    }).catch(err => console.error(err));
  };

  const submitBall = () => {
    if (!match || !match.state) return;
    const { state, meta } = match;

    const activeStriker = localStriker || state.currentStriker;
    const activeNonStriker = localNonStriker || state.currentNonStriker;
    const activeBowler = localBowler || state.currentBowler;

    if (!activeStriker || !activeNonStriker || !activeBowler) {
      alert("Please select all players (Striker, Non-Striker, Bowler) before bowling.");
      return;
    }

    // Process ball using business logic
    const result = processBallDelivery(
      state,
      meta,
      {
        runs,
        extrasType,
        isWicket,
        wicketKind: isWicket ? wicketKind : undefined,
        playerOut: isWicket ? (wicketWho === 'striker' ? activeStriker : activeNonStriker) : undefined,
        fielder: isWicket && (wicketKind === 'caught' || wicketKind === 'run_out' || wicketKind === 'stumped') ? fielder : undefined,
      },
      match.balls.length + 1,
      activeStriker,
      activeNonStriker,
      activeBowler
    );

    // Update local state based on changes
    let updatedStriker = result.newState.currentStriker;
    let updatedNonStriker = result.newState.currentNonStriker;
    let updatedBowler = result.newState.currentBowler;

    setLocalStriker(updatedStriker || "");
    setLocalNonStriker(updatedNonStriker || "");
    setLocalBowler(updatedBowler || "");

    // Check if innings completed and handle accordingly
    let finalMeta = result.newMeta;
    let finalMatchData = {
      ...match,
      meta: finalMeta,
      state: result.newState,
      balls: [...match.balls, result.newBall],
      lastUpdatedAt: Date.now()
    };

    // If innings 1 completed, save innings data
    if (result.stateChanges.inningsCompleted && meta.innings === 1) {
      const innings1Data = saveInningsData(match, 1, [...match.balls, result.newBall]);
      finalMatchData = {
        ...finalMatchData,
        innings1: innings1Data
      };
    }

    // If innings 2 completed, calculate result
    if (result.stateChanges.inningsCompleted && meta.innings === 2 && match.innings1) {
      const innings2Data = saveInningsData(match, 2, [...match.balls, result.newBall]);
      const matchResult = calculateMatchResult(match.innings1, innings2Data);

      finalMatchData = {
        ...finalMatchData,
        innings2: innings2Data,
        meta: {
          ...finalMeta,
          winningTeam: matchResult.winningTeam,
          matchResult: matchResult.resultText,
          matchResultType: matchResult.resultType
        }
      };
    }

    // Save to Firebase
    set(ref(db, dbPath), finalMatchData);

    // Reset Form
    setRuns(0);
    setExtrasType("NONE");
    setIsWicket(false);
    setFielder("");
  };

  const handleUndo = () => {
    if (match.balls.length === 0) return;
    const newHistory = match.balls.slice(0, -1);

    let r = 0, w = 0, lb = 0;
    let partnershipRuns = 0, partnershipBalls = 0;

    newHistory.forEach(b => {
      r += b.runsScored;
      if(b.isWicket) w++;
      if(!b.isWide && !b.isNoBall) {
        lb++;
        partnershipBalls++;
      }
      partnershipRuns += b.runsScored;
    });

    const lastBall = newHistory[newHistory.length - 1];

    // Determine last over bowler
    const currentOverNumber = Math.floor(lb / 6);
    let lastOverBowler: string | null = null;
    if (currentOverNumber > 0) {
      const prevOverBalls = newHistory.filter(b => b.overNumber === currentOverNumber - 1);
      if (prevOverBalls.length > 0) {
        lastOverBowler = prevOverBalls[0].bowler;
      }
    }

    const restoredStriker = lastBall ? lastBall.striker : match.state.currentStriker;
    const restoredNonStriker = lastBall ? lastBall.nonStriker : match.state.currentNonStriker;
    const restoredBowler = lastBall ? lastBall.bowler : match.state.currentBowler;

    setLocalStriker(restoredStriker || "");
    setLocalNonStriker(restoredNonStriker || "");
    setLocalBowler(restoredBowler || "");

    const restoredState = {
      totalRuns: r,
      totalWickets: w,
      legalBalls: lb,
      oversBowled: Math.floor(lb / 6),
      ballsInCurrentOver: lb % 6,
      currentStriker: restoredStriker,
      currentNonStriker: restoredNonStriker,
      currentBowler: restoredBowler,
      isFreeHit: lastBall ? (lastBall.isNoBall) : false,
      lastOverBowler,
      battingOrder: match.state.battingOrder ?? [],
      nextBatsmanIndex: match.state.nextBatsmanIndex ?? 0,
      currentPartnershipRuns: partnershipRuns,
      currentPartnershipBalls: partnershipBalls,
    };

    set(ref(db, dbPath), {
      ...match,
      state: restoredState,
      balls: newHistory,
      lastUpdatedAt: Date.now()
    });
  };

  const handleStartInnings2 = () => {
    if (!match.innings1) {
      alert("Innings 1 data not found");
      return;
    }

    const { meta, state } = prepareInnings2State(match);

    set(ref(db, dbPath), {
      ...match,
      meta,
      state,
      balls: [], // Reset balls for innings 2
      lastUpdatedAt: Date.now()
    });

    // Reset local UI
    setLocalStriker("");
    setLocalNonStriker("");
    setLocalBowler("");
  };

  // --- RENDER ---
  if (!match.state) return <div>Loading State...</div>;

  // Show innings break UI
  if (match.meta.status === "INNINGS_BREAK") {
    return (
      <div className="min-h-screen bg-gray-100 p-6">
        <div className="max-w-md mx-auto bg-white p-6 rounded-xl shadow-lg">
          <h2 className="text-2xl font-bold mb-4 text-center text-blue-900">Innings Break</h2>

          <div className="mb-6 p-4 bg-blue-50 rounded-lg">
            <h3 className="font-bold text-lg mb-2">{match.innings1?.battingTeam} Innings</h3>
            <p className="text-3xl font-bold text-blue-900">
              {match.innings1?.totalRuns}/{match.innings1?.totalWickets}
            </p>
            <p className="text-sm text-gray-600">
              Overs: {match.innings1?.oversBowled}.{match.innings1?.ballsInCurrentOver}
            </p>
          </div>

          <div className="mb-6 p-4 bg-green-50 rounded-lg border border-green-200">
            <p className="text-center text-lg">
              <span className="font-bold">{match.meta.bowlingTeam}</span> needs{" "}
              <span className="text-2xl font-bold text-green-700">
                {(match.innings1?.totalRuns ?? 0) + 1}
              </span>{" "}
              runs to win
            </p>
          </div>

          <button
            onClick={handleStartInnings2}
            className="w-full bg-green-600 text-white py-4 rounded-lg font-bold text-xl hover:bg-green-700 transition"
          >
            START INNINGS 2
          </button>
        </div>
      </div>
    );
  }

  // Show match completed UI
  if (match.meta.status === "COMPLETED") {
    return (
      <div className="min-h-screen bg-gray-100 p-6">
        <div className="max-w-md mx-auto bg-white p-6 rounded-xl shadow-lg">
          <h2 className="text-2xl font-bold mb-4 text-center text-blue-900">Match Completed</h2>

          <div className="mb-6 p-6 bg-yellow-50 rounded-lg border-2 border-yellow-400">
            <p className="text-center text-2xl font-bold text-yellow-900">
              {match.meta.matchResult}
            </p>
          </div>

          <div className="grid grid-cols-2 gap-4 mb-6">
            <div className="p-4 bg-blue-50 rounded-lg">
              <h3 className="font-bold mb-2">{match.innings1?.battingTeam}</h3>
              <p className="text-2xl font-bold">{match.innings1?.totalRuns}/{match.innings1?.totalWickets}</p>
              <p className="text-sm text-gray-600">
                {match.innings1?.oversBowled}.{match.innings1?.ballsInCurrentOver} overs
              </p>
            </div>

            <div className="p-4 bg-green-50 rounded-lg">
              <h3 className="font-bold mb-2">{match.innings2?.battingTeam}</h3>
              <p className="text-2xl font-bold">{match.innings2?.totalRuns}/{match.innings2?.totalWickets}</p>
              <p className="text-sm text-gray-600">
                {match.innings2?.oversBowled}.{match.innings2?.ballsInCurrentOver} overs
              </p>
            </div>
          </div>

          <button
            onClick={() => window.location.reload()}
            className="w-full bg-blue-600 text-white py-3 rounded-lg font-bold hover:bg-blue-700 transition"
          >
            Start New Match
          </button>
        </div>
      </div>
    );
  }

  const canPlay = localStriker && localNonStriker && localBowler && match.meta.status === 'LIVE';
  const needsFielder = isWicket && (wicketKind === 'caught' || wicketKind === 'run_out' || wicketKind === 'stumped');

  return (
    <div className="min-h-screen bg-gray-100 pb-20">
      <div className="bg-blue-900 text-white p-4 sticky top-0 z-10 shadow-lg">
        <div className="flex justify-between items-end">
          <div>
            <h2 className="text-3xl font-bold">{match.state.totalRuns}/{match.state.totalWickets}</h2>
            <p className="opacity-80">Ov: {match.state.oversBowled}.{match.state.ballsInCurrentOver} ({match.meta.oversPerInnings})</p>
            {match.meta.innings === 2 && match.meta.targetScore && (
              <p className="text-yellow-300 font-bold">
                Need {match.meta.targetScore - match.state.totalRuns} runs
              </p>
            )}
          </div>
          <div className="text-right text-sm">
            <p>{match.meta.battingTeam} Batting</p>
            <p className="text-xs">Innings {match.meta.innings}/2</p>
            <p className="text-yellow-400 font-bold">{match.state.isFreeHit ? "FREE HIT ACTIVE" : ""}</p>
          </div>
        </div>
      </div>

      {/* Statistics */}
      {(strikerStats || nonStrikerStats) && (
        <div className="p-4 bg-white border-b">
          <h3 className="text-xs font-bold text-gray-500 uppercase mb-2">Current Partnership</h3>
          <div className="grid grid-cols-2 gap-2 text-sm">
            {strikerStats && (
              <div className="p-2 bg-green-50 rounded">
                <p className="font-bold text-green-900">â˜… {strikerStats.name}</p>
                <p className="text-lg font-bold">{strikerStats.runs} ({strikerStats.balls})</p>
                <p className="text-xs text-gray-600">
                  4s: {strikerStats.fours} | 6s: {strikerStats.sixes} | SR: {strikerStats.strikeRate.toFixed(0)}
                </p>
              </div>
            )}
            {nonStrikerStats && (
              <div className="p-2 bg-gray-50 rounded">
                <p className="font-bold">{nonStrikerStats.name}</p>
                <p className="text-lg font-bold">{nonStrikerStats.runs} ({nonStrikerStats.balls})</p>
                <p className="text-xs text-gray-600">
                  4s: {nonStrikerStats.fours} | 6s: {nonStrikerStats.sixes} | SR: {nonStrikerStats.strikeRate.toFixed(0)}
                </p>
              </div>
            )}
          </div>

          {bowlerStats && (
            <div className="mt-2 p-2 bg-red-50 rounded text-sm">
              <p className="font-bold text-red-900">Bowler: {bowlerStats.name}</p>
              <p>
                {bowlerStats.overs}.{bowlerStats.balls} overs | {bowlerStats.runs} runs | {bowlerStats.wickets} wickets | Econ: {bowlerStats.economy}
              </p>
            </div>
          )}
        </div>
      )}

      {/* Players */}
      <div className="p-4 grid gap-4">
        <div className="bg-white p-4 rounded-lg shadow border-l-4 border-green-500">
          <h3 className="text-xs font-bold text-gray-500 uppercase mb-2">Batting ({match.meta.battingTeam})</h3>
          <div className="grid grid-cols-2 gap-2">
            <select
              value={localStriker}
              onChange={(e) => handleUpdatePlayer("striker", e.target.value)}
              className="border p-2 rounded w-full bg-green-50"
            >
              <option value="">Select Striker *</option>
              {battingSquad.map(p => <option key={p} value={p}>{p}</option>)}
            </select>
            <select
              value={localNonStriker}
              onChange={(e) => handleUpdatePlayer("nonStriker", e.target.value)}
              className="border p-2 rounded w-full"
            >
              <option value="">Select Non-Striker *</option>
              {battingSquad.map(p => <option key={p} value={p}>{p}</option>)}
            </select>
          </div>
        </div>

        <div className="bg-white p-4 rounded-lg shadow border-l-4 border-red-500">
          <h3 className="text-xs font-bold text-gray-500 uppercase mb-2">Bowling ({match.meta.bowlingTeam})</h3>
          <select
            value={localBowler}
            onChange={(e) => handleUpdatePlayer("bowler", e.target.value)}
            className="border p-2 rounded w-full bg-red-50"
          >
            <option value="">Select Bowler *</option>
            {bowlingSquad.map(p => <option key={p} value={p}>{p}</option>)}
          </select>
          {bowlerError && (
            <p className="text-red-600 text-sm mt-2 font-bold">{bowlerError}</p>
          )}
        </div>
      </div>

      {/* Scoring Pad */}
      <div className={`p-4 transition-all ${canPlay ? 'opacity-100' : 'opacity-40 pointer-events-none'}`}>
        <div className="grid grid-cols-4 gap-3 mb-4">
          {[0,1,2,3,4,6].map(r => (
            <button
              key={r}
              onClick={() => setRuns(r)}
              className={`h-14 rounded-lg font-bold text-xl shadow-sm border-2 ${runs === r ? 'bg-blue-600 text-white border-blue-800' : 'bg-white text-gray-800 border-gray-200'}`}
            >
              {r}
            </button>
          ))}
        </div>

        <div className="grid grid-cols-5 gap-2 mb-4">
          {(["NONE", "WD", "NB", "BYE", "LB"] as const).map(type => (
            <button
              key={type}
              onClick={() => setExtrasType(type)}
              className={`h-10 rounded text-xs font-bold border ${extrasType === type ? 'bg-orange-500 text-white border-orange-700' : 'bg-white text-gray-600 border-gray-300'}`}
            >
              {type === 'NONE' ? 'Legal' : type}
            </button>
          ))}
        </div>

        {/* Wicket Section */}
        <div className="mb-4 bg-red-50 p-3 rounded-lg border border-red-100">
          <label className="flex items-center space-x-3 cursor-pointer mb-3">
            <input
              type="checkbox"
              checked={isWicket}
              onChange={(e) => setIsWicket(e.target.checked)}
              className="w-6 h-6 text-red-600 rounded focus:ring-red-500"
            />
            <span className="font-bold text-red-700">Wicket Delivery?</span>
          </label>

          {isWicket && (
            <div className="space-y-3">
              <div className="flex gap-2">
                <button
                  onClick={() => setWicketWho("striker")}
                  className={`flex-1 py-2 text-sm font-bold border rounded transition-colors ${wicketWho === 'striker' ? 'bg-red-600 text-white border-red-700' : 'bg-white text-red-600 border-red-200'}`}
                >
                  Striker Out
                </button>
                <button
                  onClick={() => setWicketWho("nonStriker")}
                  className={`flex-1 py-2 text-sm font-bold border rounded transition-colors ${wicketWho === 'nonStriker' ? 'bg-red-600 text-white border-red-700' : 'bg-white text-red-600 border-red-200'}`}
                >
                  Non-Striker Out
                </button>
              </div>

              <select
                value={wicketKind}
                onChange={(e) => setWicketKind(e.target.value as any)}
                className="w-full border p-2 rounded text-sm"
              >
                <option value="bowled">Bowled</option>
                <option value="caught">Caught</option>
                <option value="lbw">LBW</option>
                <option value="run_out">Run Out</option>
                <option value="stumped">Stumped</option>
                <option value="hit_wicket">Hit Wicket</option>
              </select>

              {needsFielder && (
                <input
                  type="text"
                  value={fielder}
                  onChange={(e) => setFielder(e.target.value)}
                  placeholder="Fielder name"
                  className="w-full border p-2 rounded text-sm"
                />
              )}
            </div>
          )}
        </div>

        <button
          onClick={submitBall}
          className="w-full bg-blue-800 text-white h-16 rounded-xl font-bold text-xl shadow-lg active:scale-95 transition-transform"
        >
          BOWL DELIVERY
        </button>
      </div>

      <div className="p-4 border-t bg-white fixed bottom-0 w-full max-w-md">
        <button onClick={handleUndo} className="text-red-500 font-bold text-sm underline w-full text-center">Undo Last Ball</button>
      </div>
    </div>
  );
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\components\SetupMatch.tsx =====

import { useState } from "react";
import { ref, set } from "firebase/database";
import { db } from "@/lib/firebase";
import { MatchData } from "@/types";

export default function SetupMatch() {
  const [teamA, setTeamA] = useState("");
  const [teamB, setTeamB] = useState("");
  const [overs, setOvers] = useState(10);
  const [rosterA, setRosterA] = useState("");
  const [rosterB, setRosterB] = useState("");

  const handleStart = () => {
    if (!teamA || !teamB || !rosterA || !rosterB) {
      alert("Please fill in all fields");
      return;
    }

    const squadA = rosterA.split("\n").map(s => s.trim()).filter(Boolean);
    const squadB = rosterB.split("\n").map(s => s.trim()).filter(Boolean);

    if (squadA.length < 2 || squadB.length < 2) {
      alert("Each team needs at least 2 players.");
      return;
    }

    const newMatch: MatchData = {
      meta: {
        teamA,
        teamB,
        battingTeam: teamA,
        bowlingTeam: teamB,
        oversPerInnings: Number(overs),
        status: "LIVE",
        innings: 1
      },
      squads: {
        teamA: squadA,
        teamB: squadB
      },
      state: {
        totalRuns: 0,
        totalWickets: 0,
        legalBalls: 0,
        oversBowled: 0,
        ballsInCurrentOver: 0,
        currentStriker: null,
        currentNonStriker: null,
        currentBowler: null,
        isFreeHit: false,
        battingOrder: [],
        nextBatsmanIndex: 0,
        lastOverBowler: null,
        currentPartnershipRuns: 0,
        currentPartnershipBalls: 0
      },
      balls: [],
      lastUpdatedAt: Date.now()
    };

    set(ref(db, "match"), newMatch);
  };

  return (
    <div className="min-h-screen bg-gray-50 p-6 max-w-lg mx-auto">
      <h1 className="text-2xl font-bold mb-6 text-blue-900">Create New Match</h1>
      
      <div className="space-y-4 bg-white p-6 rounded-xl shadow-md">
        <div>
          <label className="block text-sm font-bold mb-1">Team A Name (Batting First)</label>
          <input className="w-full border p-2 rounded" value={teamA} onChange={e => setTeamA(e.target.value)} placeholder="e.g. India" />
        </div>
        <div>
          <label className="block text-sm font-bold mb-1">Team A Squad (Names)</label>
          <textarea 
            className="w-full border p-2 rounded h-24 text-sm" 
            placeholder="Paste names, one per line"
            value={rosterA}
            onChange={e => setRosterA(e.target.value)}
          />
        </div>

        <hr className="my-4" />

        <div>
          <label className="block text-sm font-bold mb-1">Team B Name (Bowling First)</label>
          <input className="w-full border p-2 rounded" value={teamB} onChange={e => setTeamB(e.target.value)} placeholder="e.g. Australia" />
        </div>
        <div>
          <label className="block text-sm font-bold mb-1">Team B Squad (Names)</label>
          <textarea 
            className="w-full border p-2 rounded h-24 text-sm" 
            placeholder="Paste names, one per line"
            value={rosterB}
            onChange={e => setRosterB(e.target.value)}
          />
        </div>

        <div>
          <label className="block text-sm font-bold mb-1">Overs Per Innings</label>
          <input type="number" className="w-full border p-2 rounded" value={overs} onChange={e => setOvers(Number(e.target.value))} />
        </div>

        <button 
          onClick={handleStart}
          className="w-full bg-green-600 text-white py-3 rounded-lg font-bold text-lg hover:bg-green-700 transition"
        >
          START MATCH
        </button>
      </div>
    </div>
  );
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\lib\ballProcessor.ts =====

import { Ball, MatchState, MatchMeta } from "@/types";

export interface BallInput {
  runs: number;
  extrasType: "NONE" | "WD" | "NB" | "BYE" | "LB";
  isWicket: boolean;
  wicketKind?: "bowled" | "caught" | "run_out" | "lbw" | "stumped" | "hit_wicket";
  playerOut?: string; // "striker" or "nonStriker" or player name
  fielder?: string;
}

export interface BallProcessingResult {
  newBall: Ball;
  newState: MatchState;
  newMeta: MatchMeta;
  stateChanges: {
    strikeChanged: boolean;
    overCompleted: boolean;
    wicketFell: boolean;
    needNewBatsman: boolean;
    needNewBowler: boolean;
    inningsCompleted: boolean;
  };
}

/**
 * Process a ball delivery and return new state
 */
export function processBallDelivery(
  currentState: MatchState,
  currentMeta: MatchMeta,
  ballInput: BallInput,
  ballNumber: number,
  activeStriker: string,
  activeNonStriker: string,
  activeBowler: string
): BallProcessingResult {
  // 1. Calculate runs and extras
  const isWide = ballInput.extrasType === "WD";
  const isNoBall = ballInput.extrasType === "NB";
  const isBye = ballInput.extrasType === "BYE";
  const isLegBye = ballInput.extrasType === "LB";
  const isLegal = !isWide && !isNoBall;

  // Runs off bat (0 for wides, byes, leg-byes)
  const runsByBatsman = (isWide || isBye || isLegBye) ? 0 : ballInput.runs;

  // Extra runs (1 for wide/no-ball, 0 otherwise)
  const extraRuns = (isWide || isNoBall) ? 1 : 0;

  // Total runs from this ball
  const totalBallRuns = ballInput.runs + extraRuns;

  // 2. Create ball object (Firebase doesn't accept undefined, use null or omit)
  const newBall: Ball = {
    ballNumber,
    overNumber: currentState.oversBowled,
    ballInOver: currentState.ballsInCurrentOver + 1,
    runsScored: totalBallRuns,
    runsByBatsman,
    extraRuns,
    isWide,
    isNoBall,
    isBye,
    isLegBye,
    isWicket: ballInput.isWicket,
    wicketKind: (ballInput.isWicket && ballInput.wicketKind) ? ballInput.wicketKind : null as any,
    playerOut: ballInput.isWicket ? ballInput.playerOut : null as any,
    fielder: ballInput.fielder || null as any,
    striker: activeStriker,
    nonStriker: activeNonStriker,
    bowler: activeBowler,
    isFreeHit: currentState.isFreeHit,
    partnershipRuns: (currentState.currentPartnershipRuns ?? 0) + totalBallRuns,
  };

  // 3. Update state
  let newState = { ...currentState };

  // Update runs
  newState.totalRuns += totalBallRuns;

  // Update partnership
  newState.currentPartnershipRuns = (newState.currentPartnershipRuns ?? 0) + totalBallRuns;

  // Update legal balls and over count
  if (isLegal) {
    newState.legalBalls += 1;
    newState.ballsInCurrentOver += 1;
    newState.isFreeHit = false;
    newState.currentPartnershipBalls = (newState.currentPartnershipBalls ?? 0) + 1;
  } else {
    // Set free hit for next ball if no-ball
    if (isNoBall) {
      newState.isFreeHit = true;
    }
  }

  // 4. Handle wicket
  let wicketFell = false;
  let needNewBatsman = false;

  if (ballInput.isWicket) {
    newState.totalWickets += 1;
    wicketFell = true;
    needNewBatsman = true;

    // Clear the batsman who got out
    if (ballInput.playerOut === activeStriker || ballInput.playerOut === "striker") {
      newState.currentStriker = null;
    } else {
      newState.currentNonStriker = null;
    }

    // Increment next batsman index
    newState.nextBatsmanIndex = (newState.nextBatsmanIndex ?? 0) + 1;

    // Reset partnership
    newState.currentPartnershipRuns = 0;
    newState.currentPartnershipBalls = 0;
  }

  // 5. Handle strike rotation (for odd runs)
  let strikeChanged = false;
  const runIsOdd = runsByBatsman % 2 !== 0;

  if (runIsOdd && !wicketFell) {
    const temp = newState.currentStriker;
    newState.currentStriker = newState.currentNonStriker;
    newState.currentNonStriker = temp;
    strikeChanged = true;
  }

  // 6. Handle over completion
  let overCompleted = false;
  let needNewBowler = false;

  if (newState.ballsInCurrentOver === 6) {
    newState.oversBowled += 1;
    newState.ballsInCurrentOver = 0;
    newState.lastOverBowler = newState.currentBowler;
    newState.currentBowler = null;
    overCompleted = true;
    needNewBowler = true;

    // Rotate strike at end of over
    const temp = newState.currentStriker;
    newState.currentStriker = newState.currentNonStriker;
    newState.currentNonStriker = temp;
    strikeChanged = true;
  }

  // 7. Check innings completion
  let inningsCompleted = false;
  let newStatus = currentMeta.status;

  if (newState.oversBowled >= currentMeta.oversPerInnings || newState.totalWickets >= 10) {
    inningsCompleted = true;
    // Don't set COMPLETED here if first innings
    if (currentMeta.innings === 1) {
      newStatus = "INNINGS_BREAK";
    } else {
      newStatus = "COMPLETED";
    }
  }

  // Check if target chased in second innings
  if (currentMeta.innings === 2 && currentMeta.targetScore) {
    if (newState.totalRuns >= currentMeta.targetScore) {
      inningsCompleted = true;
      newStatus = "COMPLETED";
    }
  }

  const newMeta = { ...currentMeta, status: newStatus };

  return {
    newBall,
    newState,
    newMeta,
    stateChanges: {
      strikeChanged,
      overCompleted,
      wicketFell,
      needNewBatsman,
      needNewBowler,
      inningsCompleted,
    },
  };
}

/**
 * Handle strike rotation manually
 */
export function handleStrikeRotation(state: MatchState): MatchState {
  const newState = { ...state };
  const temp = newState.currentStriker;
  newState.currentStriker = newState.currentNonStriker;
  newState.currentNonStriker = temp;
  return newState;
}

/**
 * Handle wicket manually
 */
export function handleWicket(
  state: MatchState,
  playerOut: string,
  role: "striker" | "nonStriker"
): MatchState {
  const newState = { ...state };
  newState.totalWickets += 1;

  if (role === "striker") {
    newState.currentStriker = null;
  } else {
    newState.currentNonStriker = null;
  }

  newState.nextBatsmanIndex = (newState.nextBatsmanIndex ?? 0) + 1;
  newState.currentPartnershipRuns = 0;
  newState.currentPartnershipBalls = 0;

  return newState;
}

/**
 * Handle over completion manually
 */
export function handleOverCompletion(state: MatchState): MatchState {
  const newState = { ...state };
  newState.oversBowled += 1;
  newState.ballsInCurrentOver = 0;
  newState.lastOverBowler = state.currentBowler;
  newState.currentBowler = null;

  // Rotate strike
  const temp = newState.currentStriker;
  newState.currentStriker = newState.currentNonStriker;
  newState.currentNonStriker = temp;

  return newState;
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\lib\cricketRules.ts =====

import { MatchState, MatchMeta, Ball } from "@/types";

/**
 * Validate bowler selection to enforce bowling restrictions
 * Rule: A bowler cannot bowl consecutive overs
 */
export function validateBowlerSelection(
  currentBowler: string | null,
  lastOverBowler: string | null | undefined,
  proposedBowler: string
): { valid: boolean; error?: string } {
  // If no last over bowler, any bowler can be selected
  if (!lastOverBowler) {
    return { valid: true };
  }

  // Check if proposed bowler is same as last over bowler
  if (proposedBowler === lastOverBowler) {
    return {
      valid: false,
      error: `${proposedBowler} bowled the last over and cannot bowl consecutive overs.`,
    };
  }

  return { valid: true };
}

/**
 * Validate batting order to ensure player hasn't already batted
 */
export function validateBattingOrder(
  squad: string[],
  battingOrder: string[] | undefined,
  batsmanStats: Record<string, any>,
  proposedBatsman: string
): { valid: boolean; error?: string } {
  // If no batting order tracking, allow any player
  if (!battingOrder || battingOrder.length === 0) {
    return { valid: true };
  }

  // Check if player is in the squad
  if (!squad.includes(proposedBatsman)) {
    return {
      valid: false,
      error: `${proposedBatsman} is not in the squad.`,
    };
  }

  // Check if player has already batted and is out
  if (batsmanStats[proposedBatsman]) {
    const stats = batsmanStats[proposedBatsman];
    if (stats.isOut) {
      return {
        valid: false,
        error: `${proposedBatsman} is already out and cannot bat again.`,
      };
    }
  }

  return { valid: true };
}

/**
 * Check if innings is complete
 */
export function isInningsComplete(state: MatchState, meta: MatchMeta): boolean {
  // Innings complete if all overs bowled
  if (state.oversBowled >= meta.oversPerInnings) {
    return true;
  }

  // Innings complete if 10 wickets down
  if (state.totalWickets >= 10) {
    return true;
  }

  return false;
}

/**
 * Get next batsman from batting order
 */
export function getNextBatsman(
  battingOrder: string[] | undefined,
  nextBatsmanIndex: number | undefined,
  batsmanStats: Record<string, any>
): string | null {
  if (!battingOrder || battingOrder.length === 0) {
    return null;
  }

  const index = nextBatsmanIndex ?? 0;

  // Find next batsman who hasn't batted yet
  for (let i = index; i < battingOrder.length; i++) {
    const player = battingOrder[i];
    const stats = batsmanStats[player];

    // If player hasn't batted yet or is not out, they can bat
    if (!stats || !stats.isOut) {
      return player;
    }
  }

  return null;
}

/**
 * Validate if match can progress (all required players selected)
 */
export function canProgressMatch(state: MatchState): { valid: boolean; error?: string } {
  if (!state.currentStriker) {
    return { valid: false, error: "Please select a striker" };
  }

  if (!state.currentNonStriker) {
    return { valid: false, error: "Please select a non-striker" };
  }

  if (!state.currentBowler) {
    return { valid: false, error: "Please select a bowler" };
  }

  if (state.currentStriker === state.currentNonStriker) {
    return { valid: false, error: "Striker and non-striker cannot be the same player" };
  }

  return { valid: true };
}

/**
 * Get last over bowler from balls array
 */
export function getLastOverBowler(balls: Ball[], currentOverNumber: number): string | null {
  if (currentOverNumber === 0) return null;

  const lastOverNumber = currentOverNumber - 1;

  // Find balls from last over
  const lastOverBalls = balls.filter((b) => b.overNumber === lastOverNumber);

  // Return the bowler from the last over
  if (lastOverBalls.length > 0) {
    return lastOverBalls[0].bowler;
  }

  return null;
}

/**
 * Check if target has been chased in second innings
 */
export function isTargetChased(currentRuns: number, targetScore: number | undefined): boolean {
  if (!targetScore) return false;
  return currentRuns >= targetScore;
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\lib\firebase.ts =====

import { initializeApp, getApps, getApp } from "firebase/app";
import { getDatabase } from "firebase/database";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  databaseURL: process.env.NEXT_PUBLIC_FIREBASE_DB_URL,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

// Singleton pattern to prevent multiple initializations
const app = !getApps().length ? initializeApp(firebaseConfig) : getApp();
export const db = getDatabase(app);


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\lib\inningsManager.ts =====

import { MatchData, MatchMeta, MatchState, InningsData, Ball } from "@/types";
import {
  calculateAllBatsmanStats,
  calculateAllBowlerStats,
  calculateFallOfWickets,
  calculatePartnerships,
  calculateExtras,
} from "./statsCalculator";

/**
 * Check if should transition to innings break
 */
export function shouldTransitionToInningsBreak(state: MatchState, meta: MatchMeta): boolean {
  // Only transition if in first innings
  if (meta.innings !== 1) return false;

  // Check if innings is complete
  if (state.oversBowled >= meta.oversPerInnings || state.totalWickets >= 10) {
    return true;
  }

  return false;
}

/**
 * Save innings data snapshot
 */
export function saveInningsData(
  matchData: MatchData,
  inningsNumber: 1 | 2,
  balls: Ball[]
): InningsData {
  const { state, meta, squads } = matchData;

  // Determine batting and bowling squads
  const battingSquad = meta.battingTeam === meta.teamA ? squads.teamA : squads.teamB;
  const bowlingSquad = meta.battingTeam === meta.teamA ? squads.teamB : squads.teamA;

  const inningsData: InningsData = {
    battingTeam: meta.battingTeam,
    bowlingTeam: meta.bowlingTeam,
    totalRuns: state.totalRuns,
    totalWickets: state.totalWickets,
    oversBowled: state.oversBowled,
    ballsInCurrentOver: state.ballsInCurrentOver,
    legalBalls: state.legalBalls,
    fallOfWickets: calculateFallOfWickets(balls),
    partnerships: calculatePartnerships(balls),
    batsmanStats: calculateAllBatsmanStats(balls, battingSquad),
    bowlerStats: calculateAllBowlerStats(balls, bowlingSquad),
    extras: calculateExtras(balls),
  };

  return inningsData;
}

/**
 * Prepare state and meta for second innings
 */
export function prepareInnings2State(matchData: MatchData): {
  meta: MatchMeta;
  state: MatchState;
} {
  const { meta, state } = matchData;

  // Calculate target score (innings1 total + 1)
  const targetScore = state.totalRuns + 1;

  // Swap batting and bowling teams
  const newMeta: MatchMeta = {
    ...meta,
    innings: 2,
    battingTeam: meta.bowlingTeam,
    bowlingTeam: meta.battingTeam,
    targetScore,
    status: "LIVE",
  };

  // Reset state for new innings
  const newState: MatchState = {
    totalRuns: 0,
    totalWickets: 0,
    legalBalls: 0,
    oversBowled: 0,
    ballsInCurrentOver: 0,
    currentStriker: null,
    currentNonStriker: null,
    currentBowler: null,
    isFreeHit: false,
    battingOrder: state.battingOrder ?? [],
    nextBatsmanIndex: 0,
    lastOverBowler: null,
    currentPartnershipRuns: 0,
    currentPartnershipBalls: 0,
  };

  return { meta: newMeta, state: newState };
}

/**
 * Calculate match result from both innings
 */
export function calculateMatchResult(
  innings1: InningsData,
  innings2: InningsData
): {
  winningTeam: string;
  resultText: string;
  resultType: "runs" | "wickets" | "tie" | "no_result";
} {
  const team1 = innings1.battingTeam;
  const team2 = innings2.battingTeam;
  const team1Score = innings1.totalRuns;
  const team2Score = innings2.totalRuns;

  // Check if tie
  if (team1Score === team2Score) {
    return {
      winningTeam: "Tie",
      resultText: "Match tied",
      resultType: "tie",
    };
  }

  // Team 2 won
  if (team2Score > team1Score) {
    const wicketsRemaining = 10 - innings2.totalWickets;
    return {
      winningTeam: team2,
      resultText: `${team2} won by ${wicketsRemaining} wicket${wicketsRemaining === 1 ? "" : "s"}`,
      resultType: "wickets",
    };
  }

  // Team 1 won
  const runsDifference = team1Score - team2Score;
  return {
    winningTeam: team1,
    resultText: `${team1} won by ${runsDifference} run${runsDifference === 1 ? "" : "s"}`,
    resultType: "runs",
  };
}

/**
 * Check if second innings should end early (target chased)
 */
export function shouldEndInnings2Early(
  currentRuns: number,
  targetScore: number | undefined
): boolean {
  if (!targetScore) return false;
  return currentRuns >= targetScore;
}

/**
 * Get match summary text
 */
export function getMatchSummary(matchData: MatchData): string {
  const { meta, innings1, innings2 } = matchData;

  if (meta.status === "NOT_STARTED") {
    return "Match not started";
  }

  if (meta.status === "LIVE") {
    if (meta.innings === 1) {
      return `${meta.battingTeam} batting`;
    } else {
      return `${meta.battingTeam} chasing ${meta.targetScore}`;
    }
  }

  if (meta.status === "INNINGS_BREAK") {
    if (innings1) {
      return `Innings break - ${innings1.battingTeam}: ${innings1.totalRuns}/${innings1.totalWickets}`;
    }
    return "Innings break";
  }

  if (meta.status === "COMPLETED" && meta.matchResult) {
    return meta.matchResult;
  }

  return "Match completed";
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\lib\statsCalculator.ts =====

import { Ball, BatsmanStats, BowlerStats, FallOfWicket, Partnership, InningsData, MatchState } from "@/types";

/**
 * Calculate batsman statistics from ball history
 */
export function calculateBatsmanStats(balls: Ball[], playerName: string): BatsmanStats {
  let runs = 0;
  let ballsFaced = 0;
  let fours = 0;
  let sixes = 0;
  let isOut = false;
  let howOut = "";

  balls.forEach((ball) => {
    // Check if this player was the striker
    if (ball.striker === playerName) {
      // Count balls faced (only legal balls)
      if (!ball.isWide && !ball.isNoBall) {
        ballsFaced++;
      }

      // Count runs (only runs off bat, not extras)
      const runsOffBat = ball.runsByBatsman ?? (ball.isBye || ball.isLegBye ? 0 : ball.runsScored);
      runs += runsOffBat;

      // Count boundaries
      if (runsOffBat === 4) fours++;
      if (runsOffBat === 6) sixes++;

      // Check if out
      if (ball.isWicket && ball.playerOut === playerName) {
        isOut = true;
        if (ball.wicketKind) {
          if (ball.wicketKind === "bowled") {
            howOut = `b ${ball.bowler}`;
          } else if (ball.wicketKind === "caught") {
            howOut = ball.fielder ? `c ${ball.fielder} b ${ball.bowler}` : `c & b ${ball.bowler}`;
          } else if (ball.wicketKind === "lbw") {
            howOut = `lbw b ${ball.bowler}`;
          } else if (ball.wicketKind === "stumped") {
            howOut = ball.fielder ? `st ${ball.fielder} b ${ball.bowler}` : `st b ${ball.bowler}`;
          } else if (ball.wicketKind === "run_out") {
            howOut = ball.fielder ? `run out (${ball.fielder})` : "run out";
          } else if (ball.wicketKind === "hit_wicket") {
            howOut = `hit wicket b ${ball.bowler}`;
          } else {
            howOut = "out";
          }
        }
      }
    }

    // Also check if non-striker and got run out
    if (ball.nonStriker === playerName && ball.isWicket && ball.playerOut === playerName) {
      isOut = true;
      howOut = ball.fielder ? `run out (${ball.fielder})` : "run out";
    }
  });

  const strikeRate = ballsFaced > 0 ? (runs / ballsFaced) * 100 : 0;

  const stats: any = {
    name: playerName,
    runs,
    balls: ballsFaced,
    fours,
    sixes,
    strikeRate: parseFloat(strikeRate.toFixed(2)),
    isOut,
  };

  // Only add howOut if player is actually out (Firebase doesn't accept undefined)
  if (isOut && howOut) {
    stats.howOut = howOut;
  }

  return stats;
}

/**
 * Calculate bowler statistics from ball history
 */
export function calculateBowlerStats(balls: Ball[], playerName: string): BowlerStats {
  let ballsBowled = 0;
  let runs = 0;
  let wickets = 0;
  let maidens = 0;
  let wides = 0;
  let noBalls = 0;

  // Group balls by over to calculate maidens
  const overBalls: Record<number, Ball[]> = {};

  balls.forEach((ball) => {
    if (ball.bowler === playerName) {
      // Count legal balls
      if (!ball.isWide && !ball.isNoBall) {
        ballsBowled++;
      }

      // Count runs (all runs conceded)
      runs += ball.runsScored;

      // Count wickets (excluding run outs)
      if (ball.isWicket && ball.wicketKind !== "run_out") {
        wickets++;
      }

      // Count extras
      if (ball.isWide) wides++;
      if (ball.isNoBall) noBalls++;

      // Group by over for maiden calculation
      if (!overBalls[ball.overNumber]) {
        overBalls[ball.overNumber] = [];
      }
      overBalls[ball.overNumber].push(ball);
    }
  });

  // Calculate maidens (overs with 0 runs)
  Object.values(overBalls).forEach((overBallsArray) => {
    const legalBallsInOver = overBallsArray.filter((b) => !b.isWide && !b.isNoBall).length;
    const runsInOver = overBallsArray.reduce((sum, b) => sum + b.runsScored, 0);

    // Maiden: 6 legal balls with 0 runs
    if (legalBallsInOver === 6 && runsInOver === 0) {
      maidens++;
    }
  });

  const overs = Math.floor(ballsBowled / 6);
  const remainingBalls = ballsBowled % 6;
  const economy = ballsBowled > 0 ? (runs / ballsBowled) * 6 : 0;

  return {
    name: playerName,
    overs,
    balls: remainingBalls,
    runs,
    wickets,
    economy: parseFloat(economy.toFixed(2)),
    maidens,
    wides,
    noBalls,
  };
}

/**
 * Calculate fall of wickets from ball history
 */
export function calculateFallOfWickets(balls: Ball[]): FallOfWicket[] {
  const fallOfWickets: FallOfWicket[] = [];
  let wicketCount = 0;
  let totalRuns = 0;

  balls.forEach((ball) => {
    totalRuns += ball.runsScored;

    if (ball.isWicket && ball.playerOut) {
      wicketCount++;
      const fow: any = {
        playerOut: ball.playerOut,
        score: totalRuns,
        wicketNumber: wicketCount,
        oversBowled: ball.overNumber,
        ballsInOver: ball.ballInOver,
        wicketKind: ball.wicketKind || "out",
        bowler: ball.bowler,
      };

      // Only add fielder if it exists (Firebase doesn't accept undefined)
      if (ball.fielder) {
        fow.fielder = ball.fielder;
      }

      fallOfWickets.push(fow);
    }
  });

  return fallOfWickets;
}

/**
 * Calculate partnerships from ball history
 */
export function calculatePartnerships(balls: Ball[]): Partnership[] {
  const partnerships: Partnership[] = [];
  let currentBatsman1: string | null = null;
  let currentBatsman2: string | null = null;
  let currentPartnershipRuns = 0;
  let currentPartnershipBalls = 0;
  let currentStartWicket = 0;

  balls.forEach((ball) => {
    // Initialize partnership if first ball
    if (!currentBatsman1 && !currentBatsman2) {
      currentBatsman1 = ball.striker;
      currentBatsman2 = ball.nonStriker;
    }

    // Check if batsmen changed (wicket fell or new partnership)
    const currentPair = [ball.striker, ball.nonStriker].sort();
    const previousPair = [currentBatsman1, currentBatsman2].sort();

    if (currentPair[0] !== previousPair[0] || currentPair[1] !== previousPair[1]) {
      // Save previous partnership
      if (currentBatsman1 && currentBatsman2) {
        partnerships.push({
          batsman1: currentBatsman1,
          batsman2: currentBatsman2,
          runs: currentPartnershipRuns,
          balls: currentPartnershipBalls,
          startWicket: currentStartWicket,
          endWicket: currentStartWicket + 1,
          isActive: false,
        });
      }

      // Start new partnership
      currentBatsman1 = ball.striker;
      currentBatsman2 = ball.nonStriker;
      currentPartnershipRuns = 0;
      currentPartnershipBalls = 0;
      currentStartWicket++;
    }

    // Count runs and balls for current partnership
    currentPartnershipRuns += ball.runsScored;
    if (!ball.isWide && !ball.isNoBall) {
      currentPartnershipBalls++;
    }
  });

  // Add final active partnership
  if (currentBatsman1 && currentBatsman2) {
    partnerships.push({
      batsman1: currentBatsman1,
      batsman2: currentBatsman2,
      runs: currentPartnershipRuns,
      balls: currentPartnershipBalls,
      startWicket: currentStartWicket,
      isActive: true,
    });
  }

  return partnerships;
}

/**
 * Calculate extras breakdown from ball history
 */
export function calculateExtras(balls: Ball[]): {
  wides: number;
  noBalls: number;
  byes: number;
  legByes: number;
  total: number;
} {
  let wides = 0;
  let noBalls = 0;
  let byes = 0;
  let legByes = 0;

  balls.forEach((ball) => {
    if (ball.isWide) wides += ball.runsScored;
    if (ball.isNoBall) noBalls += 1; // No-ball is always 1 + any runs
    if (ball.isBye) byes += ball.runsScored;
    if (ball.isLegBye) legByes += ball.runsScored;
  });

  return {
    wides,
    noBalls,
    byes,
    legByes,
    total: wides + noBalls + byes + legByes,
  };
}

/**
 * Calculate run rate
 */
export function calculateRunRate(runs: number, balls: number): number {
  if (balls === 0) return 0;
  const overs = balls / 6;
  return parseFloat((runs / overs).toFixed(2));
}

/**
 * Calculate required run rate for chase
 */
export function calculateRequiredRunRate(
  target: number,
  runsScored: number,
  ballsRemaining: number
): number {
  if (ballsRemaining === 0) return 0;
  const runsNeeded = target - runsScored;
  if (runsNeeded <= 0) return 0;
  const oversRemaining = ballsRemaining / 6;
  return parseFloat((runsNeeded / oversRemaining).toFixed(2));
}

/**
 * Calculate all batsmen statistics for an innings
 */
export function calculateAllBatsmanStats(balls: Ball[], squad: string[]): Record<string, BatsmanStats> {
  const stats: Record<string, BatsmanStats> = {};

  squad.forEach((playerName) => {
    const playerStats = calculateBatsmanStats(balls, playerName);
    // Only include if player has faced balls or is out
    if (playerStats.balls > 0 || playerStats.isOut) {
      stats[playerName] = playerStats;
    }
  });

  return stats;
}

/**
 * Calculate all bowler statistics for an innings
 */
export function calculateAllBowlerStats(balls: Ball[], squad: string[]): Record<string, BowlerStats> {
  const stats: Record<string, BowlerStats> = {};

  squad.forEach((playerName) => {
    const playerStats = calculateBowlerStats(balls, playerName);
    // Only include if player has bowled balls
    if (playerStats.balls > 0 || playerStats.overs > 0) {
      stats[playerName] = playerStats;
    }
  });

  return stats;
}

/**
 * Get current partnership from state
 */
export function getCurrentPartnership(state: MatchState): { runs: number; balls: number } {
  return {
    runs: state.currentPartnershipRuns ?? 0,
    balls: state.currentPartnershipBalls ?? 0,
  };
}


===== FILE: C:\Users\Omkar\Desktop\Firstprinciples\cricket_app_vgct\vcl_mvp\cricket-admin\src\types\index.ts =====

export type TeamName = "teamA" | "teamB";

export interface Player {
  id: string; // use name as ID for simplicity
  name: string;
}

export interface Wicket {
  isOut: boolean;
  kind?: "bowled" | "caught" | "run_out" | "lbw" | "stumped" | null;
  playerOut?: string; // name
}

// Player Statistics
export interface BatsmanStats {
  name: string;
  runs: number;
  balls: number;
  fours: number;
  sixes: number;
  strikeRate: number;
  isOut: boolean;
  howOut?: string;
}

export interface BowlerStats {
  name: string;
  overs: number;
  balls: number;
  runs: number;
  wickets: number;
  economy: number;
  maidens: number;
  wides: number;
  noBalls: number;
}

// Fall of Wickets
export interface FallOfWicket {
  playerOut: string;
  score: number;
  wicketNumber: number;
  oversBowled: number;
  ballsInOver: number;
  wicketKind: string;
  bowler: string;
  fielder?: string;
}

// Partnership
export interface Partnership {
  batsman1: string;
  batsman2: string;
  runs: number;
  balls: number;
  startWicket: number;
  endWicket?: number;
  isActive: boolean;
}

// Innings Data
export interface InningsData {
  battingTeam: string;
  bowlingTeam: string;
  totalRuns: number;
  totalWickets: number;
  oversBowled: number;
  ballsInCurrentOver: number;
  legalBalls: number;
  fallOfWickets: FallOfWicket[];
  partnerships: Partnership[];
  batsmanStats: Record<string, BatsmanStats>;
  bowlerStats: Record<string, BowlerStats>;
  extras: {
    wides: number;
    noBalls: number;
    byes: number;
    legByes: number;
    total: number;
  };
}

export interface Ball {
  ballNumber: number; // Global index
  overNumber: number;
  ballInOver: number; // 1-6 (or more if extras)

  // Scoring
  runsScored: number; // Total runs from this ball
  runsByBatsman?: number; // NEW: Runs off bat (for stats)
  extraRuns?: number; // NEW: Extra runs

  // Extras
  isWide: boolean;
  isNoBall: boolean;
  isBye?: boolean; // NEW
  isLegBye?: boolean; // NEW

  // Wickets
  isWicket: boolean;
  wicketKind?: string;
  playerOut?: string;
  fielder?: string; // NEW: For caught/run out/stumped

  // Context (Snapshot for Undo/History)
  striker: string;
  nonStriker: string;
  bowler: string;
  isFreeHit: boolean;

  // Partnership
  partnershipRuns?: number; // NEW
}

export interface MatchMeta {
  teamA: string; // Name
  teamB: string; // Name
  oversPerInnings: number;
  status: "NOT_STARTED" | "LIVE" | "INNINGS_BREAK" | "COMPLETED";
  innings: number;
  battingTeam: string; // Name
  bowlingTeam: string; // Name
  winningTeam?: string;

  // NEW: Second innings support
  targetScore?: number;
  matchResult?: string;
  matchResultType?: "runs" | "wickets" | "tie" | "no_result";
}

export interface MatchState {
  totalRuns: number;
  totalWickets: number;
  legalBalls: number; // Total legal balls bowled
  oversBowled: number; // e.g., 2
  ballsInCurrentOver: number; // e.g., 4

  // Current Actors
  currentStriker: string | null;
  currentNonStriker: string | null;
  currentBowler: string | null;

  isFreeHit: boolean; // Next ball is free hit?

  // NEW: Batting order tracking
  battingOrder?: string[];
  nextBatsmanIndex?: number;

  // NEW: Over history for bowling restrictions
  lastOverBowler?: string | null;

  // NEW: Current partnership
  currentPartnershipRuns?: number;
  currentPartnershipBalls?: number;
}

// Roster Storage
export interface Squads {
  teamA: string[];
  teamB: string[];
}

export interface MatchData {
  meta: MatchMeta;
  squads: Squads;
  state: MatchState;
  balls: Ball[];

  // NEW: Innings-wise data
  innings1?: InningsData;
  innings2?: InningsData;

  lastUpdatedAt: number;
}
